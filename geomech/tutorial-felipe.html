<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>An√°lise de Seguran√ßa Geomec√¢nica para Inje√ß√£o em Reservat√≥rios</title>
    <style>
        :root {
            --primary-color: #1a56db;
            --secondary-color: #4f81bd;
            --accent-color: #ec7d31;
            --light-bg: #f5f7fa;
            --dark-text: #333;
            --light-text: #fff;
            --border-color: #ddd;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--dark-text);
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        
        header {
            background: linear-gradient(135deg, var(--primary-color), #4338ca);
            color: var(--light-text);
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXR0ZXJuIGlkPSJncmlkIiB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHBhdHRlcm5Vbml0cz0idXNlclNwYWNlT25Vc2UiIHBhdHRlcm5UcmFuc2Zvcm09InJvdGF0ZSgzMCkiPjxwYXRoIGQ9Ik0gNDAgMCBMIDAgMCAwIDQwIiBzdHJva2U9InJnYmEoMjU1LDI1NSwyNTUsMC4xKSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIi8+PC9wYXR0ZXJuPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9InVybCgjZ3JpZCkiLz48L3N2Zz4=');
            opacity: 0.2;
        }
        
        h1, h2, h3, h4 {
            font-weight: 600;
            margin-top: 30px;
        }
        
        h1 {
            font-size: 2.4em;
            text-align: center;
            color: var(--light-text);
            margin-top: 0;
            position: relative;
            z-index: 1;
        }
        
        h2 {
            font-size: 1.8em;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
            margin-top: 40px;
            color: var(--primary-color);
        }
        
        h3 {
            font-size: 1.4em;
            margin-top: 25px;
            color: var(--secondary-color);
        }
        
        .section {
            background-color: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s, box-shadow 0.3s;
            border: 1px solid rgba(0,0,0,0.05);
        }
        
        .section:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }
        
        .formula-box {
            background-color: var(--light-bg);
            border-left: 4px solid var(--accent-color);
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
            overflow-x: auto;
            transition: background-color 0.3s;
        }
        
        .formula-box:hover {
            background-color: #edf2f7;
        }
        
        .formula {
            font-family: 'Cambria Math', Georgia, serif;
            font-size: 1.2em;
            margin: 10px 0;
            display: block;
        }
        
        .formula-description {
            margin-top: 10px;
            font-style: italic;
        }
        
        .canvas-container {
            margin: 20px 0;
            text-align: center;
            position: relative;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }
        
        canvas {
            border: 1px solid var(--border-color);
            background-color: white;
            border-radius: 8px;
            max-width: 100%;
            transition: transform 0.3s;
        }
        
        .canvas-container:hover canvas {
            transform: scale(1.01);
        }
        
        .two-column {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
        }
        
        .column {
            flex: 1;
            min-width: 300px;
        }
        
        .note {
            background-color: #fff8dc;
            border-left: 4px solid #ffd700;
            padding: 15px 20px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
            position: relative;
        }
        
        .note::before {
            content: 'üìù';
            position: absolute;
            top: 15px;
            left: -30px;
            font-size: 16px;
        }
        
        .important {
            background-color: #ffe6e6;
            border-left: 4px solid #ff6666;
            padding: 15px 20px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
            font-weight: bold;
            position: relative;
        }
        
        .important::before {
            content: '‚ö†Ô∏è';
            position: absolute;
            top: 15px;
            left: -30px;
            font-size: 16px;
        }
        
        .workflow-step {
            background-color: var(--light-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            margin: 25px 0;
            position: relative;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        
        .workflow-step:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
        }
        
        .workflow-step::before {
            content: attr(data-step);
            position: absolute;
            top: -15px;
            left: 20px;
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.1);
        }
        
        .workflow-step h4 {
            margin-top: 10px;
            color: var(--primary-color);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
        }
        
        th {
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            color: white;
            font-weight: bold;
        }
        
        tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        
        tr:hover {
            background-color: #f1f1f1;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .tab {
            padding: 12px 20px;
            cursor: pointer;
            background-color: #f1f1f1;
            transition: all 0.3s;
            flex: 1;
            text-align: center;
            border: none;
            font-weight: 500;
        }
        
        .tab:hover {
            background-color: #e1e1e1;
        }
        
        .tab.active {
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            color: white;
            font-weight: bold;
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .tab-content.active {
            display: block;
        }
        
        .slider-container {
            margin: 20px 0;
            padding: 10px;
            background-color: var(--light-bg);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .slider {
            width: 100%;
            cursor: pointer;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 15px 0;
        }
        
        .control-group {
            flex: 1;
            min-width: 250px;
            padding: 15px;
            background-color: var(--light-bg);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        
        .map-container {
            position: relative;
            height: 400px;
            margin: 25px 0;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .map-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            z-index: 1000;
        }
        
        .legend {
            background-color: white;
            padding: 10px;
            border-radius: 8px;
            display: inline-block;
            margin-top: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        
        .legend-color {
            width: 20px;
            height: 15px;
            margin-right: 10px;
            border-radius: 3px;
        }
        
        .button {
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        /* Estilos para o painel de controle flutuante */
        .floating-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            max-width: 300px;
            transition: all 0.3s;
            transform: translateX(310px);
        }
        
        .floating-controls.visible {
            transform: translateX(0);
        }
        
        .toggle-controls {
            position: absolute;
            left: -60px;
            top: 0;
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 10px;
            border-radius: 10px 0 0 10px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: -4px 0 10px rgba(0, 0, 0, 0.1);
        }
        
        .toggle-controls:hover {
            background: var(--secondary-color);
        }
        
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .card {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s, box-shadow 0.3s;
            border: 1px solid var(--border-color);
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
        }
        
        .card-title {
            color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }
        
        /* Design responsivo */
        @media (max-width: 768px) {
            .card-grid {
                grid-template-columns: 1fr;
            }
            
            .floating-controls {
                max-width: 250px;
            }
            
            header {
                padding: 20px;
            }
            
            h1 {
                font-size: 1.8em;
            }
        }
        
        /* Anima√ß√µes */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <header>
        <h1>An√°lise de Seguran√ßa Geomec√¢nica para Inje√ß√£o em Reservat√≥rios</h1>
        <p style="text-align: center; margin-bottom: 0; position: relative; z-index: 1;">Metodologia completa incluindo efeitos poroel√°sticos</p>
    </header>

    <div class="section">
        <h2>Introdu√ß√£o</h2>
        <p>Esta metodologia apresenta uma abordagem sistem√°tica para avaliar a seguran√ßa de opera√ß√µes de inje√ß√£o em reservat√≥rios de petr√≥leo, considerando tanto a possibilidade de fraturamento hidr√°ulico quanto por cisalhamento. A an√°lise utiliza conceitos fundamentais de geomec√¢nica e incorpora efeitos poroel√°sticos para uma avalia√ß√£o mais precisa dos riscos operacionais.</p>
        
        <div class="important">
            A opera√ß√£o segura de inje√ß√£o de fluidos em reservat√≥rios requer manter as press√µes abaixo dos limites cr√≠ticos de fraturamento. Este protocolo fornece metodologia para identificar esses limites e calcular fatores de seguran√ßa apropriados para cada ponto do reservat√≥rio.
        </div>
    </div>

    <div class="section">
        <h2>Conceitos Fundamentais</h2>
        
        <div class="tabs">
            <div class="tab active" onclick="changeTab(event, 'stress-state')">Estado de Tens√µes</div>
            <div class="tab" onclick="changeTab(event, 'pore-pressure')">Press√£o de Poros</div>
            <div class="tab" onclick="changeTab(event, 'poroelastic')">Efeito Poroel√°stico</div>
        </div>
        
        <div id="stress-state" class="tab-content active">
            <h3>Estado de Tens√µes in situ</h3>
            <p>As tens√µes principais atuantes em um ponto do reservat√≥rio s√£o:</p>
            <div class="formula-box">
                <span class="formula">œÉ<sub>v</sub> = œÅ<sub>r</sub> √ó g √ó z</span>
                <span class="formula">œÉ<sub>Hmax</sub> = f(œÉ<sub>v</sub>, regime tect√¥nico)</span>
                <span class="formula">œÉ<sub>hmin</sub> = f(œÉ<sub>v</sub>, regime tect√¥nico)</span>
                <div class="formula-description">
                    Onde:<br>
                    œÉ<sub>v</sub> = Tens√£o vertical (gradiente de sobrecarga)<br>
                    œÉ<sub>Hmax</sub> = Tens√£o horizontal m√°xima<br>
                    œÉ<sub>hmin</sub> = Tens√£o horizontal m√≠nima<br>
                    œÅ<sub>r</sub> = Densidade m√©dia das rochas sobrepostas<br>
                    g = Acelera√ß√£o da gravidade<br>
                    z = Profundidade
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <h4>Par√¢metros de Entrada</h4>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Densidade da rocha:</span>
                            <span id="density-value">2500 kg/m¬≥</span>
                        </div>
                        <input type="range" min="2000" max="3000" value="2500" class="slider" id="density-slider" oninput="updateStressPlot()">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Regime tect√¥nico:</span>
                            <span id="tectonic-value">Normal</span>
                        </div>
                        <select id="tectonic-regime" onchange="updateStressPlot()" class="select">
                            <option value="normal">Normal (œÉv > œÉHmax > œÉhmin)</option>
                            <option value="strike-slip">Transcorrente (œÉHmax > œÉv > œÉhmin)</option>
                            <option value="reverse">Reverso (œÉHmax > œÉhmin > œÉv)</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="stressGradientCanvas" width="800" height="500"></canvas>
            </div>
            
            <div class="map-container">
                <canvas id="stressDistributionMap" width="800" height="400"></canvas>
                <div class="map-overlay">
                    <h4>Visualiza√ß√£o de Tens√µes</h4>
                    <select id="stress-view-type" onchange="updateStressMap()">
                        <option value="sv">Tens√£o Vertical (œÉv)</option>
                        <option value="shmin">Tens√£o Horizontal M√≠nima (œÉhmin)</option>
                        <option value="shmax">Tens√£o Horizontal M√°xima (œÉHmax)</option>
                        <option value="diff">Diferencial de Tens√£o (œÉ1-œÉ3)</option>
                    </select>
                </div>
            </div>
        </div>
        
        <div id="pore-pressure" class="tab-content">
            <h3>Press√£o de Poros</h3>
            <p>A press√£o de poros inicial e sua evolu√ß√£o durante a inje√ß√£o influenciam diretamente a estabilidade do reservat√≥rio:</p>
            <div class="formula-box">
                <span class="formula">P<sub>p</sub> = P<sub>p_inicial</sub> + ŒîP<sub>inje√ß√£o</sub></span>
                <div class="formula-description">
                    Onde:<br>
                    P<sub>p</sub> = Press√£o de poros atual<br>
                    P<sub>p_inicial</sub> = Press√£o de poros inicial (normalmente hidrost√°tica ou anormalmente pressurizada)<br>
                    ŒîP<sub>inje√ß√£o</sub> = Incremento de press√£o devido √† inje√ß√£o de fluidos
                </div>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <h4>Par√¢metros de Inje√ß√£o</h4>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Gradiente de press√£o inicial:</span>
                            <span id="pp-gradient-value">10 kPa/m</span>
                        </div>
                        <input type="range" min="8" max="20" value="10" step="0.1" class="slider" id="pp-gradient-slider" oninput="updatePorePressurePlot()">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Intensidade de inje√ß√£o:</span>
                            <span id="injection-value">50%</span>
                        </div>
                        <input type="range" min="0" max="100" value="50" class="slider" id="injection-slider" oninput="updatePorePressurePlot()">
                    </div>
                </div>
            </div>
            
            <div class="canvas-container">
                <canvas id="porePressureCanvas" width="800" height="500"></canvas>
            </div>
            
            <div class="map-container">
                <canvas id="pressureDistributionMap" width="800" height="400"></canvas>
                <div class="map-overlay">
                    <h4>Visualiza√ß√£o de Press√£o</h4>
                    <select id="pressure-time" onchange="updatePressureMap()">
                        <option value="initial">Press√£o Inicial</option>
                        <option value="mid">Durante Inje√ß√£o (50%)</option>
                        <option value="final">Ap√≥s Inje√ß√£o (100%)</option>
                    </select>
                </div>
            </div>
        </div>
        
        <div id="poroelastic" class="tab-content">
            <h3>Efeitos Poroel√°sticos</h3>
            <p>Os efeitos poroel√°sticos descrevem a intera√ß√£o entre a press√£o de fluido e a deforma√ß√£o do meio poroso. Quando a press√£o aumenta, parte deste aumento √© transferida para a tens√£o total, alterando o equil√≠brio de for√ßas no reservat√≥rio:</p>
            
            <div class="formula-box">
                <span class="formula">ŒîœÉ<sub>ij</sub> = Œ± √ó (K<sub>u</sub>/3) √ó (1 + ŒΩ<sub>u</sub>)/(1 - ŒΩ<sub>u</sub>) √ó ŒîP<sub>p</sub> √ó Œ¥<sub>ij</sub></span>
                <div class="formula-description">
                    Onde:<br>
                    ŒîœÉ<sub>ij</sub> = Varia√ß√£o no tensor de tens√µes<br>
                    Œ± = Coeficiente de Biot<br>
                    K<sub>u</sub> = M√≥dulo volum√©trico n√£o-drenado<br>
                    ŒΩ<sub>u</sub> = Raz√£o de Poisson n√£o-drenada<br>
                    ŒîP<sub>p</sub> = Varia√ß√£o na press√£o de poros<br>
                    Œ¥<sub>ij</sub> = Delta de Kronecker
                </div>
            </div>
            
            <p>Para casos pr√°ticos, utilizamos estas aproxima√ß√µes:</p>
            
            <div class="formula-box">
                <span class="formula">ŒîœÉ<sub>hmin</sub> = (Œ±/3) √ó (1 + ŒΩ)/(1 - ŒΩ) √ó ŒîP<sub>p</sub></span>
                <span class="formula">ŒîœÉ<sub>Hmax</sub> = (Œ±/3) √ó (1 + ŒΩ)/(1 - ŒΩ) √ó ŒîP<sub>p</sub></span>
                <span class="formula">ŒîœÉ<sub>v</sub> = (Œ±/3) √ó (1 + ŒΩ)/(1 - ŒΩ) √ó ŒîP<sub>p</sub> √ó (condi√ß√£o de deforma√ß√£o)</span>
            </div>
            
            <div class="note">
                <strong>Import√¢ncia dos efeitos poroel√°sticos:</strong> Quando a press√£o de poros aumenta, parte deste aumento √© transferida para a tens√£o total, reduzindo o aumento efetivo na press√£o de poros. Isso significa que a tens√£o de confinamento tamb√©m aumenta parcialmente com a press√£o de poros, n√£o apenas diminui como na teoria cl√°ssica de Terzaghi.
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <h4>Par√¢metros Poroel√°sticos</h4>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Coeficiente de Biot (Œ±):</span>
                            <span id="biot-value">0.8</span>
                        </div>
                        <input type="range" min="0.1" max="1" value="0.8" step="0.05" class="slider" id="biot-slider" oninput="updatePoroelasticPlot()">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Raz√£o de Poisson (ŒΩ):</span>
                            <span id="poisson-value">0.25</span>
                        </div>
                        <input type="range" min="0.1" max="0.45" value="0.25" step="0.01" class="slider" id="poisson-slider" oninput="updatePoroelasticPlot()">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Varia√ß√£o de Press√£o (ŒîP):</span>
                            <span id="deltap-value">10 MPa</span>
                        </div>
                        <input type="range" min="0" max="30" value="10" class="slider" id="deltap-slider" oninput="updatePoroelasticPlot()">
                    </div>
                </div>
            </div>
            
            <div class="canvas-container">
                <canvas id="poroelasticCanvas" width="800" height="500"></canvas>
            </div>
            
            <div class="map-container">
                <canvas id="poroelasticMap" width="800" height="400"></canvas>
                <div class="map-overlay">
                    <h4>Visualiza√ß√£o do Efeito Poroel√°stico</h4>
                    <select id="poroelastic-component" onchange="updatePoroelasticMap()">
                        <option value="dshmin">Varia√ß√£o em œÉhmin</option>
                        <option value="dshmax">Varia√ß√£o em œÉHmax</option>
                        <option value="dsv">Varia√ß√£o em œÉv</option>
                        <option value="factor">Fator Poroel√°stico</option>
                    </select>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>Crit√©rios de Falha</h2>
        
        <div class="tabs">
            <div class="tab active" onclick="changeTab(event, 'tensile')">Fraturamento Hidr√°ulico</div>
            <div class="tab" onclick="changeTab(event, 'shear')">Cisalhamento</div>
            <div class="tab" onclick="changeTab(event, 'mohr')">C√≠rculo de Mohr</div>
        </div>
        
        <div id="tensile" class="tab-content active">
            <h3>Fraturamento Hidr√°ulico (Tensional)</h3>
            <p>O fraturamento hidr√°ulico ocorre quando a press√£o de poros excede a tens√£o m√≠nima de confinamento, considerando os efeitos poroel√°sticos:</p>
            
            <div class="formula-box">
                <span class="formula">P<sub>f</sub> = œÉ<sub>hmin</sub> + ŒîœÉ<sub>hmin_poroel√°stico</sub></span>
                <span class="formula">P<sub>f</sub> = œÉ<sub>hmin_inicial</sub> + (Œ±/3) √ó (1 + ŒΩ)/(1 - ŒΩ) √ó (P<sub>p</sub> - P<sub>p_inicial</sub>)</span>
                <div class="formula-description">
                    Onde:<br>
                    P<sub>f</sub> = Press√£o de fraturamento hidr√°ulico<br>
                    œÉ<sub>hmin</sub> = Tens√£o horizontal m√≠nima total<br>
                    œÉ<sub>hmin_inicial</sub> = Tens√£o horizontal m√≠nima inicial<br>
                    ŒîœÉ<sub>hmin_poroel√°stico</sub> = Contribui√ß√£o poroel√°stica
                </div>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <h4>Par√¢metros de Fraturamento</h4>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Gradiente œÉhmin:</span>
                            <span id="shmin-gradient-value">16 kPa/m</span>
                        </div>
                        <input type="range" min="12" max="22" value="16" step="0.1" class="slider" id="shmin-gradient-slider" oninput="updateTensilePlot()">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Taxa de inje√ß√£o:</span>
                            <span id="injection-rate-value">50 m¬≥/dia</span>
                        </div>
                        <input type="range" min="0" max="200" value="50" class="slider" id="injection-rate-slider" oninput="updateTensilePlot()">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Considerar efeito poroel√°stico:</span>
                        </div>
                        <label class="switch">
                            <input type="checkbox" id="poroelastic-toggle" checked onchange="updateTensilePlot()">
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="canvas-container">
                <canvas id="tensileFailureCanvas" width="800" height="500"></canvas>
            </div>
            
            <div class="map-container">
                <canvas id="tensileFailureMap" width="800" height="400"></canvas>
                <div class="map-overlay">
                    <h4>Mapa de Risco de Fraturamento</h4>
                    <select id="tensile-map-type" onchange="updateTensileMap()">
                        <option value="pressure">Press√£o de Inje√ß√£o</option>
                        <option value="frac-pressure">Press√£o de Fraturamento</option>
                        <option value="sf">Fator de Seguran√ßa</option>
                    </select>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #10b981;"></div>
                            <span>SF > 1.5 (Seguro)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #f59e0b;"></div>
                            <span>1.0 < SF < 1.5 (Aten√ß√£o)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #ef4444;"></div>
                            <span>SF < 1.0 (Falha)</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="shear" class="tab-content">
            <h3>Fraturamento por Cisalhamento</h3>
            <p>O cisalhamento ocorre quando as tens√µes cisalhantes excedem a resist√™ncia ao cisalhamento da rocha, conforme o crit√©rio de Mohr-Coulomb:</p>
            
            <div class="formula-box">
                <span class="formula">œÑ = C + œÉ'<sub>n</sub> √ó tan(œÜ)</span>
                <div class="formula-description">
                    Onde:<br>
                    œÑ = Resist√™ncia ao cisalhamento<br>
                    C = Coes√£o da rocha<br>
                    œÉ'<sub>n</sub> = Tens√£o normal efetiva<br>
                    œÜ = √Çngulo de atrito interno
                </div>
            </div>
            
            <p>A press√£o de cisalhamento pode ser estimada considerando efeitos poroel√°sticos:</p>
            
            <div class="formula-box">
                <span class="formula">P<sub>f_cisalhamento</sub> = [(œÉ<sub>1</sub> - œÉ<sub>3</sub>)/2] - [(œÉ<sub>1</sub> + œÉ<sub>3</sub>)/2 - P<sub>p</sub>] √ó sin(œÜ) - C √ó cos(œÜ)</span>
                <div class="formula-description">
                    Ajustada para efeitos poroel√°sticos:<br>
                    œÉ<sub>1</sub> = œÉ<sub>1_inicial</sub> + ŒîœÉ<sub>1_poroel√°stico</sub><br>
                    œÉ<sub>3</sub> = œÉ<sub>3_inicial</sub> + ŒîœÉ<sub>3_poroel√°stico</sub>
                </div>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <h4>Par√¢metros de Cisalhamento</h4>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Coes√£o (C):</span>
                            <span id="cohesion-value">5 MPa</span>
                        </div>
                        <input type="range" min="1" max="20" value="5" class="slider" id="cohesion-slider" oninput="updateShearPlot()">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>√Çngulo de atrito (œÜ):</span>
                            <span id="friction-angle-value">30¬∞</span>
                        </div>
                        <input type="range" min="10" max="45" value="30" class="slider" id="friction-angle-slider" oninput="updateShearPlot()">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Raz√£o œÉ1/œÉ3:</span>
                            <span id="stress-ratio-value">2.0</span>
                        </div>
                        <input type="range" min="1.2" max="3" value="2" step="0.1" class="slider" id="stress-ratio-slider" oninput="updateShearPlot()">
                    </div>
                </div>
            </div>
            
            <div class="canvas-container">
                <canvas id="shearFailureCanvas" width="800" height="500"></canvas>
            </div>
            
            <div class="map-container">
                <canvas id="shearFailureMap" width="800" height="400"></canvas>
                <div class="map-overlay">
                    <h4>Mapa de Risco de Cisalhamento</h4>
                    <select id="shear-map-type" onchange="updateShearMap()">
                        <option value="differential">Tens√£o Diferencial</option>
                        <option value="shear-strength">Resist√™ncia ao Cisalhamento</option>
                        <option value="sf">Fator de Seguran√ßa</option>
                    </select>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #10b981;"></div>
                            <span>SF > 1.5 (Seguro)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #f59e0b;"></div>
                            <span>1.0 < SF < 1.5 (Aten√ß√£o)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #ef4444;"></div>
                            <span>SF < 1.0 (Falha)</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="mohr" class="tab-content">
            <h3>Visualiza√ß√£o do C√≠rculo de Mohr</h3>
            <p>O c√≠rculo de Mohr √© uma representa√ß√£o gr√°fica do estado de tens√µes em um ponto, permitindo visualizar a proximidade da falha. Aqui voc√™ pode interagir com o diagrama para entender como a press√£o de poros e efeitos poroel√°sticos afetam a estabilidade da rocha:</p>
            
            <div class="controls">
                <div class="control-group">
                    <h4>Par√¢metros do C√≠rculo de Mohr</h4>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Tens√£o Principal M√°xima (œÉ1):</span>
                            <span id="sigma1-value">40 MPa</span>
                        </div>
                        <input type="range" min="20" max="80" value="40" class="slider" id="sigma1-slider" oninput="updateMohrCircle()">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Tens√£o Principal M√≠nima (œÉ3):</span>
                            <span id="sigma3-value">20 MPa</span>
                        </div>
                        <input type="range" min="5" max="40" value="20" class="slider" id="sigma3-slider" oninput="updateMohrCircle()">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Press√£o de Poros (Pp):</span>
                            <span id="pp-value">10 MPa</span>
                        </div>
                        <input type="range" min="0" max="30" value="10" class="slider" id="pp-slider" oninput="updateMohrCircle()">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Anima√ß√£o de Inje√ß√£o:</span>
                        </div>
                        <button id="animate-button" class="button" onclick="animateMohrCircle()">Iniciar Anima√ß√£o</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <h4>Envelope de Falha</h4>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Coes√£o (C):</span>
                            <span id="mohr-cohesion-value">5 MPa</span>
                        </div>
                        <input type="range" min="0" max="20" value="5" class="slider" id="mohr-cohesion-slider" oninput="updateMohrCircle()">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>√Çngulo de Atrito (œÜ):</span>
                            <span id="mohr-friction-value">30¬∞</span>
                        </div>
                        <input type="range" min="15" max="45" value="30" class="slider" id="mohr-friction-slider" oninput="updateMohrCircle()">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Mostrar efeitos poroel√°sticos:</span>
                        </div>
                        <label class="switch">
                            <input type="checkbox" id="mohr-poroelastic-toggle" checked onchange="updateMohrCircle()">
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="canvas-container">
                <canvas id="mohrCircleCanvas" width="800" height="500"></canvas>
            </div>
            
            <div class="note">
                O c√≠rculo de Mohr se move para a esquerda quando a press√£o de poros aumenta (redu√ß√£o da tens√£o efetiva), mas tamb√©m pode mudar de tamanho devido aos efeitos poroel√°sticos que afetam diferentemente cada componente de tens√£o.
            </div>
        </div>
    </div>

    <div class="section">
        <h2>Fatores de Seguran√ßa</h2>
        
        <h3>Avalia√ß√£o Quantitativa de Risco</h3>
        <p>Os fatores de seguran√ßa permitem quantificar a proximidade das condi√ß√µes de opera√ß√£o em rela√ß√£o aos limites cr√≠ticos de falha:</p>
        
        <div class="card-grid">
            <div class="card">
                <h4 class="card-title">Fator de Seguran√ßa para Fraturamento Hidr√°ulico</h4>
                <div class="formula-box">
                    <span class="formula">FS<sub>hidr√°ulico</sub> = P<sub>f</sub> / P<sub>p_final</sub></span>
                    <div class="formula-description">
                        Onde:<br>
                        FS<sub>hidr√°ulico</sub> = Fator de seguran√ßa contra fraturamento hidr√°ulico<br>
                        P<sub>f</sub> = Press√£o de fraturamento (incluindo efeitos poroel√°sticos)<br>
                        P<sub>p_final</sub> = Press√£o de poros ap√≥s inje√ß√£o
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h4 class="card-title">Fator de Seguran√ßa para Cisalhamento</h4>
                <div class="formula-box">
                    <span class="formula">FS<sub>cisalhamento</sub> = œÑ<sub>max_permitido</sub> / œÑ<sub>atual</sub></span>
                    <span class="formula">œÑ<sub>max_permitido</sub> = C + œÉ'<sub>n</sub> √ó tan(œÜ)</span>
                    <span class="formula">œÑ<sub>atual</sub> = (œÉ<sub>1</sub>' - œÉ<sub>3</sub>')/2</span>
                    <div class="formula-description">
                        Valores consideram efeitos poroel√°sticos em todas as componentes
                    </div>
                </div>
            </div>
        </div>
        
        <h3>Visualiza√ß√£o de Fatores de Seguran√ßa no Reservat√≥rio</h3>
        <p>Mapas 3D de fatores de seguran√ßa permitem identificar zonas cr√≠ticas no reservat√≥rio:</p>
        
        <div class="canvas-container">
            <canvas id="safetyFactorCanvas" width="800" height="500"></canvas>
            <div class="controls">
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Plano de visualiza√ß√£o:</span>
                    </div>
                    <select id="view-plane" onchange="updateSafetyFactorView()">
                        <option value="horizontal">Horizontal (mapa)</option>
                        <option value="vertical-x">Vertical (se√ß√£o X)</option>
                        <option value="vertical-y">Vertical (se√ß√£o Y)</option>
                    </select>
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Posi√ß√£o do corte:</span>
                        <span id="slice-position-value">50%</span>
                    </div>
                    <input type="range" min="0" max="100" value="50" class="slider" id="slice-position-slider" oninput="updateSafetyFactorView()">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Modo de visualiza√ß√£o:</span>
                    </div>
                    <select id="safety-view-mode" onchange="updateSafetyFactorView()">
                        <option value="hydraulic">Fator de Seguran√ßa Hidr√°ulico</option>
                        <option value="shear">Fator de Seguran√ßa Cisalhamento</option>
                        <option value="minimum">Fator de Seguran√ßa M√≠nimo</option>
                        <option value="risk">Zonas de Risco</option>
                    </select>
                </div>
            </div>
        </div>
        
        <div class="important">
            Um fator de seguran√ßa menor que 1,0 indica falha iminente. Na pr√°tica, recomenda-se manter FS > 1,2 para ter uma margem de seguran√ßa adequada considerando incertezas nos par√¢metros.
        </div>
    </div>

    <div class="section">
        <h2>Metodologia Passo a Passo</h2>
        
        <div class="workflow-step" data-step="1">
            <h4>Caracteriza√ß√£o do Estado de Tens√µes Inicial</h4>
            <p>Determina√ß√£o dos gradientes de tens√£o para cada componente principal:</p>
            <div class="two-column">
                <div class="column">
                    <ul>
                        <li>Gradiente de tens√£o vertical (œÉ<sub>v</sub>)</li>
                        <li>Gradiente de tens√£o horizontal m√≠nima (œÉ<sub>hmin</sub>)</li>
                        <li>Gradiente de tens√£o horizontal m√°xima (œÉ<sub>Hmax</sub>)</li>
                        <li>Gradiente de press√£o de poros inicial (P<sub>p_inicial</sub>)</li>
                    </ul>
                </div>
                <div class="column">
                    <div class="canvas-container" style="height: 200px;">
                        <canvas id="workflowStep1Canvas" width="350" height="200"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="workflow-step" data-step="2">
            <h4>Determina√ß√£o das Propriedades Mec√¢nicas da Rocha</h4>
            <p>Estimativa das propriedades que influenciam o comportamento mec√¢nico:</p>
            <div class="two-column">
                <div class="column">
                    <strong>Propriedades Medidas:</strong>
                    <ul>
                        <li>M√≥dulo de Young (E)</li>
                        <li>Raz√£o de Poisson (ŒΩ)</li>
                    </ul>
                    <strong>Propriedades Estimadas:</strong>
                    <ul>
                        <li>Coes√£o (C) - a partir de correla√ß√µes</li>
                        <li>√Çngulo de atrito (œÜ) - a partir de correla√ß√µes</li>
                        <li>Coeficiente de Biot (Œ±) - para efeitos poroel√°sticos</li>
                    </ul>
                </div>
                <div class="column">
                    <div class="canvas-container" style="height: 200px;">
                        <canvas id="workflowStep2Canvas" width="350" height="200"></canvas>
                    </div>
                </div>
            </div>
            
            <table>
                <tr>
                    <th>Litologia</th>
                    <th>Coes√£o (C) - Estimada</th>
                    <th>√Çngulo de Atrito (œÜ) - Estimado</th>
                    <th>Coef. Biot (Œ±) - Estimado</th>
                </tr>
                <tr>
                    <td>Arenito</td>
                    <td>C ‚âà 0.02 √ó E (MPa)</td>
                    <td>25-35¬∞</td>
                    <td>0.7-0.9</td>
                </tr>
                <tr>
                    <td>Carbonato</td>
                    <td>C ‚âà 0.03 √ó E (MPa)</td>
                    <td>30-40¬∞</td>
                    <td>0.6-0.8</td>
                </tr>
                <tr>
                    <td>Folhelho</td>
                    <td>C ‚âà 0.015 √ó E (MPa)</td>
                    <td>15-25¬∞</td>
                    <td>0.8-1.0</td>
                </tr>
            </table>
        </div>
        
        <div class="workflow-step" data-step="3">
            <h4>C√°lculo dos Efeitos Poroel√°sticos</h4>
            <p>Determina√ß√£o do acoplamento entre press√£o de poros e tens√µes:</p>
            <div class="two-column">
                <div class="column">
                    <div class="formula-box">
                        <span class="formula">K<sub>poro</sub> = (1 + ŒΩ)/(1 - ŒΩ) √ó (1/3)</span>
                        <span class="formula">ŒîœÉ<sub>hmin</sub> = Œ± √ó ŒîP<sub>p</sub> √ó K<sub>poro</sub></span>
                        <span class="formula">ŒîœÉ<sub>Hmax</sub> = Œ± √ó ŒîP<sub>p</sub> √ó K<sub>poro</sub></span>
                        <span class="formula">ŒîœÉ<sub>v</sub> = Œ± √ó ŒîP<sub>p</sub> √ó K<sub>poro</sub> √ó K<sub>deform</sub></span>
                    </div>
                </div>
                <div class="column">
                    <div class="canvas-container" style="height: 200px;">
                        <canvas id="workflowStep3Canvas" width="350" height="200"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="workflow-step" data-step="4">
            <h4>Simula√ß√£o de Press√£o de Inje√ß√£o</h4>
            <p>Uso do simulador para obter o volume de press√£o ap√≥s inje√ß√£o em cada c√©lula do modelo:</p>
            <div class="two-column">
                <div class="column">
                    <ul>
                        <li>Importar o modelo est√°tico para o simulador</li>
                        <li>Definir par√¢metros de inje√ß√£o (vaz√£o, press√£o m√°xima, etc.)</li>
                        <li>Executar a simula√ß√£o e obter o campo de press√µes (P<sub>p_final</sub>)</li>
                    </ul>
                </div>
                <div class="column">
                    <div class="canvas-container" style="height: 200px;">
                        <canvas id="workflowStep4Canvas" width="350" height="200"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="workflow-step" data-step="5">
            <h4>C√°lculo dos Fatores de Seguran√ßa</h4>
            <p>Para cada c√©lula do modelo, calcular os fatores de seguran√ßa considerando efeitos poroel√°sticos:</p>
            <div class="two-column">
                <div class="column">
                    <div class="formula-box">
                        <span class="formula">FS<sub>hidr√°ulico</sub> = P<sub>f</sub> / P<sub>p_final</sub></span>
                        <span class="formula">FS<sub>cisalhamento</sub> = œÑ<sub>max_permitido</sub> / œÑ<sub>atual</sub></span>
                    </div>
                </div>
                <div class="column">
                    <div class="canvas-container" style="height: 200px;">
                        <canvas id="workflowStep5Canvas" width="350" height="200"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="workflow-step" data-step="6">
            <h4>Visualiza√ß√£o e An√°lise dos Resultados</h4>
            <p>Mapeamento de zonas cr√≠ticas e ajuste dos par√¢metros operacionais:</p>
            <div class="two-column">
                <div class="column">
                    <ul>
                        <li>Identificar regi√µes com FS < 1,2</li>
                        <li>Ajustar volumes e taxas de inje√ß√£o</li>
                        <li>Modificar posicionamento de po√ßos, se necess√°rio</li>
                        <li>Repetir os c√°lculos ap√≥s ajustes</li>
                    </ul>
                </div>
                <div class="column">
                    <div class="canvas-container" style="height: 200px;">
                        <canvas id="workflowStep6Canvas" width="350" height="200"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>Implementa√ß√£o em Petrel</h2>
        
        <h3>Fluxo de Trabalho no Petrel</h3>
        <div class="card-grid">
            <div class="card">
                <h4 class="card-title">1. Cria√ß√£o de propriedades para tens√µes iniciais</h4>
                <ul>
                    <li>Calcular œÉ<sub>v</sub> = f(profundidade)</li>
                    <li>Calcular œÉ<sub>hmin</sub> = f(profundidade)</li>
                    <li>Calcular œÉ<sub>Hmax</sub> = f(profundidade)</li>
                </ul>
            </div>
            
            <div class="card">
                <h4 class="card-title">2. Cria√ß√£o de propriedades para par√¢metros rochosos</h4>
                <ul>
                    <li>Importar/calcular m√≥dulo de Young (E)</li>
                    <li>Importar/calcular raz√£o de Poisson (ŒΩ)</li>
                    <li>Calcular coes√£o (C) e √¢ngulo de atrito (œÜ)</li>
                    <li>Calcular coeficiente de Biot (Œ±)</li>
                </ul>
            </div>
            
            <div class="card">
                <h4 class="card-title">3. Fator poroel√°stico</h4>
                <div class="formula-box">
                    <span class="formula">K<sub>poro</sub> = (1 + ŒΩ)/(1 - ŒΩ) √ó (1/3)</span>
                </div>
            </div>
            
            <div class="card">
                <h4 class="card-title">4. Importa√ß√£o de resultados de simula√ß√£o</h4>
                <ul>
                    <li>Importar P<sub>p_inicial</sub></li>
                    <li>Importar P<sub>p_final</sub> (ap√≥s inje√ß√£o)</li>
                </ul>
            </div>
            
            <div class="card">
                <h4 class="card-title">5. C√°lculo de press√µes de fratura</h4>
                <div class="formula-box">
                    <span class="formula">P<sub>f</sub> = œÉ<sub>hmin</sub> + Œ± √ó K<sub>poro</sub> √ó (P<sub>p_final</sub> - P<sub>p_inicial</sub>)</span>
                </div>
            </div>
            
            <div class="card">
                <h4 class="card-title">6. C√°lculo dos fatores de seguran√ßa</h4>
                <div class="formula-box">
                    <span class="formula">FS<sub>hidr√°ulico</sub> = P<sub>f</sub> / P<sub>p_final</sub></span>
                    <span class="formula">FS<sub>cisalhamento</sub> = œÑ<sub>max_permitido</sub> / œÑ<sub>atual</sub></span>
                </div>
            </div>
        </div>
        
        <div class="map-container">
            <canvas id="petrelWorkflowCanvas" width="800" height="400"></canvas>
            <div class="map-overlay">
                <h4>Visualiza√ß√£o do Workflow no Petrel</h4>
                <select id="petrel-workflow-step" onchange="updatePetrelWorkflow()">
                    <option value="model">Modelo Geol√≥gico</option>
                    <option value="properties">Propriedades da Rocha</option>
                    <option value="pressure">Campo de Press√µes</option>
                    <option value="safety">Fatores de Seguran√ßa</option>
                </select>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>Conclus√µes e Recomenda√ß√µes</h2>
        
        <div class="important">
            <p>Os fatores de seguran√ßa devem sempre considerar os efeitos poroel√°sticos para maior precis√£o na an√°lise de risco.</p>
        </div>
        
        <h3>Recomenda√ß√µes Gerais</h3>
        <ul>
            <li>Manter FS > 1,2 para todos os pontos do reservat√≥rio</li>
            <li>Realizar an√°lises de sensibilidade para os par√¢metros mais incertos</li>
            <li>Monitorar press√µes de fundo durante opera√ß√µes de inje√ß√£o</li>
            <li>Ajustar par√¢metros operacionais conforme necess√°rio durante a vida do projeto</li>
        </ul>
        
        <h3>Limita√ß√µes da Metodologia</h3>
        <ul>
            <li>Assume comportamento linear-el√°stico da rocha</li>
            <li>N√£o considera heterogeneidades em escala muito fina</li>
            <li>Requer calibra√ß√£o com dados de testes de inje√ß√£o reais quando dispon√≠veis</li>
        </ul>
    </div>

    <div class="floating-controls">
        <button class="toggle-controls">Controles</button>
        <h3>Par√¢metros Globais</h3>
        
        <div class="slider-container">
            <div class="slider-label">
                <span>Profundidade de refer√™ncia:</span>
                <span id="global-depth-value">2000 m</span>
            </div>
            <input type="range" min="1000" max="4000" value="2000" class="slider" id="global-depth-slider" oninput="updateGlobalParameters()">
        </div>
        
        <div class="slider-container">
            <div class="slider-label">
                <span>Regime tect√¥nico:</span>
            </div>
            <select id="global-tectonic-regime" onchange="updateGlobalParameters()">
                <option value="normal">Normal (œÉv > œÉHmax > œÉhmin)</option>
                <option value="strike-slip">Transcorrente (œÉHmax > œÉv > œÉhmin)</option>
                <option value="reverse">Reverso (œÉHmax > œÉhmin > œÉv)</option>
            </select>
        </div>
        
        <div class="slider-container">
            <div class="slider-label">
                <span>Taxa de inje√ß√£o global:</span>
                <span id="global-injection-value">50%</span>
            </div>
            <input type="range" min="0" max="100" value="50" class="slider" id="global-injection-slider" oninput="updateGlobalParameters()">
        </div>
        
        <div class="slider-container">
            <div class="slider-label">
                <span>Considerar efeitos poroel√°sticos:</span>
            </div>
            <label class="switch">
                <input type="checkbox" id="global-poroelastic-toggle" checked onchange="updateGlobalParameters()">
                <span class="slider round"></span>
            </label>
        </div>
        
        <button class="button" onclick="resetParameters()">Resetar Par√¢metros</button>
    </div>

    <script>
        // Vari√°veis globais para os canvases
        let stressGradientCanvas, stressDistributionMap;
        let porePressureCanvas, pressureDistributionMap;
        let poroelasticCanvas, poroelasticMap;
        let tensileFailureCanvas, tensileFailureMap;
        let shearFailureCanvas, shearFailureMap;
        let mohrCircleCanvas;
        let safetyFactorCanvas;
        let workflowCanvases = [];
        let petrelWorkflowCanvas;
        
        // Vari√°veis para simula√ß√£o de dados 3D
        let simulatedData = {
            dimensions: {x: 50, y: 30, z: 20},
            pressureField: [],
            stressField: {sv: [], shmin: [], shmax: []},
            poroelasticEffect: {sv: [], shmin: [], shmax: []},
            safetyFactors: {tensile: [], shear: []}
        };
        
        // Fun√ß√£o para inicializar os canvases
        function initCanvases() {
            stressGradientCanvas = document.getElementById('stressGradientCanvas').getContext('2d');
            stressDistributionMap = document.getElementById('stressDistributionMap').getContext('2d');
            
            porePressureCanvas = document.getElementById('porePressureCanvas').getContext('2d');
            pressureDistributionMap = document.getElementById('pressureDistributionMap').getContext('2d');
            
            poroelasticCanvas = document.getElementById('poroelasticCanvas').getContext('2d');
            poroelasticMap = document.getElementById('poroelasticMap').getContext('2d');
            
            tensileFailureCanvas = document.getElementById('tensileFailureCanvas').getContext('2d');
            tensileFailureMap = document.getElementById('tensileFailureMap').getContext('2d');
            
            shearFailureCanvas = document.getElementById('shearFailureCanvas').getContext('2d');
            shearFailureMap = document.getElementById('shearFailureMap').getContext('2d');
            
            mohrCircleCanvas = document.getElementById('mohrCircleCanvas').getContext('2d');
            
            safetyFactorCanvas = document.getElementById('safetyFactorCanvas').getContext('2d');
            
            for (let i = 1; i <= 6; i++) {
                workflowCanvases.push(document.getElementById(`workflowStep${i}Canvas`).getContext('2d'));
            }
            
            petrelWorkflowCanvas = document.getElementById('petrelWorkflowCanvas').getContext('2d');
            
            // Inicializar dados simulados
            initializeSimulatedData();
            
            // Desenhar todos os gr√°ficos iniciais
            drawAllPlots();
        }
        
        // Inicializar dados simulados para visualiza√ß√µes 3D
        function initializeSimulatedData() {
            const {x, y, z} = simulatedData.dimensions;
            
            // Inicializar campo de press√£o
            simulatedData.pressureField = Array(z).fill().map((_, zIdx) => 
                Array(y).fill().map((_, yIdx) => 
                    Array(x).fill().map((_, xIdx) => {
                        // Press√£o base aumentando com a profundidade
                        const baseP = 10 + 0.01 * zIdx;
                        
                        // Adicionar uma "pluma" de inje√ß√£o no centro
                        const dx = xIdx - x/2;
                        const dy = yIdx - y/2;
                        const dz = zIdx - z/2;
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        const injectP = Math.max(0, 15 * (1 - dist/Math.sqrt(x*x + y*y + z*z) * 2));
                        
                        return baseP + injectP;
                    })
                )
            );
            
            // Inicializar campos de tens√£o
            simulatedData.stressField.sv = Array(z).fill().map((_, zIdx) => 
                Array(y).fill().map(() => 
                    Array(x).fill().map(() => 25 + 0.022 * zIdx)
                )
            );
            
            simulatedData.stressField.shmin = Array(z).fill().map((_, zIdx) => 
                Array(y).fill().map(() => 
                    Array(x).fill().map(() => 15 + 0.016 * zIdx)
                )
            );
            
            simulatedData.stressField.shmax = Array(z).fill().map((_, zIdx) => 
                Array(y).fill().map(() => 
                    Array(x).fill().map(() => 20 + 0.019 * zIdx)
                )
            );
            
            // Inicializar efeitos poroel√°sticos (baseado na press√£o)
            const biot = 0.8;
            const poisson = 0.25;
            const poroFactor = (biot/3) * (1 + poisson)/(1 - poisson);
            
            for (let zIdx = 0; zIdx < z; zIdx++) {
                simulatedData.poroelasticEffect.sv[zIdx] = [];
                simulatedData.poroelasticEffect.shmin[zIdx] = [];
                simulatedData.poroelasticEffect.shmax[zIdx] = [];
                
                for (let yIdx = 0; yIdx < y; yIdx++) {
                    simulatedData.poroelasticEffect.sv[zIdx][yIdx] = [];
                    simulatedData.poroelasticEffect.shmin[zIdx][yIdx] = [];
                    simulatedData.poroelasticEffect.shmax[zIdx][yIdx] = [];
                    
                    for (let xIdx = 0; xIdx < x; xIdx++) {
                        const baseP = 10 + 0.01 * zIdx;
                        const deltaP = simulatedData.pressureField[zIdx][yIdx][xIdx] - baseP;
                        
                        simulatedData.poroelasticEffect.sv[zIdx][yIdx][xIdx] = poroFactor * deltaP;
                        simulatedData.poroelasticEffect.shmin[zIdx][yIdx][xIdx] = poroFactor * deltaP;
                        simulatedData.poroelasticEffect.shmax[zIdx][yIdx][xIdx] = poroFactor * deltaP;
                    }
                }
            }
            
            // Calcular fatores de seguran√ßa
            simulatedData.safetyFactors.tensile = Array(z).fill().map((_, zIdx) => 
                Array(y).fill().map((_, yIdx) => 
                    Array(x).fill().map((_, xIdx) => {
                        const pressure = simulatedData.pressureField[zIdx][yIdx][xIdx];
                        const shmin = simulatedData.stressField.shmin[zIdx][yIdx][xIdx];
                        const poroEffect = simulatedData.poroelasticEffect.shmin[zIdx][yIdx][xIdx];
                        
                        // Fator de seguran√ßa = press√£o de fratura / press√£o atual
                        return (shmin + poroEffect) / pressure;
                    })
                )
            );
            
            // Fator de seguran√ßa ao cisalhamento (simplificado)
            const cohesion = 5; // MPa
            const friction = 30 * Math.PI / 180; // radianos
            
            simulatedData.safetyFactors.shear = Array(z).fill().map((_, zIdx) => 
                Array(y).fill().map((_, yIdx) => 
                    Array(x).fill().map((_, xIdx) => {
                        const pressure = simulatedData.pressureField[zIdx][yIdx][xIdx];
                        const sv = simulatedData.stressField.sv[zIdx][yIdx][xIdx];
                        const shmin = simulatedData.stressField.shmin[zIdx][yIdx][xIdx];
                        
                        // Tens√µes efetivas 
                        const sv_eff = sv - biot * pressure;
                        const shmin_eff = shmin - biot * pressure;
                        
                        // Tens√£o diferencial e normal m√©dia
                        const diff_stress = sv_eff - shmin_eff;
                        const mean_stress = (sv_eff + shmin_eff) / 2;
                        
                        // Resist√™ncia ao cisalhamento
                        const shear_strength = cohesion + mean_stress * Math.sin(friction);
                        
                        // Fator de seguran√ßa = resist√™ncia / tens√£o atual
                        return shear_strength / (diff_stress/2);
                    })
                )
            );
        }
        
        // Fun√ß√£o para desenhar todos os gr√°ficos
        function drawAllPlots() {
            updateStressPlot();
            updateStressMap();
            updatePorePressurePlot();
            updatePressureMap();
            updatePoroelasticPlot();
            updatePoroelasticMap();
            updateTensilePlot();
            updateTensileMap();
            updateShearPlot();
            updateShearMap();
            updateMohrCircle();
            updateSafetyFactorView();
            updateWorkflowGraphics();
            updatePetrelWorkflow();
        }
        
        // Fun√ß√µes para manipula√ß√£o das abas
        function changeTab(event, tabName) {
            var tabsContainer = event.currentTarget.parentElement;
            var contentContainer = tabsContainer.nextElementSibling;
            while (contentContainer && !contentContainer.classList.contains('tab-content')) {
                contentContainer = contentContainer.nextElementSibling;
            }
            
            if (!contentContainer) return;
            
            var tabs = tabsContainer.getElementsByClassName("tab");
            for (var i = 0; i < tabs.length; i++) {
                tabs[i].className = tabs[i].className.replace(" active", "");
            }
            
            var parent = contentContainer.parentElement;
            var tabContents = parent.getElementsByClassName("tab-content");
            for (var i = 0; i < tabContents.length; i++) {
                tabContents[i].className = tabContents[i].className.replace(" active", "");
            }
            
            event.currentTarget.className += " active";
            document.getElementById(tabName).className += " active";
            
            // Redesenhar o canvas relevante
            switch(tabName) {
                case 'stress-state':
                    updateStressPlot();
                    updateStressMap();
                    break;
                case 'pore-pressure':
                    updatePorePressurePlot();
                    updatePressureMap();
                    break;
                case 'poroelastic':
                    updatePoroelasticPlot();
                    updatePoroelasticMap();
                    break;
                case 'tensile':
                    updateTensilePlot();
                    updateTensileMap();
                    break;
                case 'shear':
                    updateShearPlot();
                    updateShearMap();
                    break;
                case 'mohr':
                    updateMohrCircle();
                    break;
            }
        }
        
        // Fun√ß√£o para atualizar plot de tens√µes
        function updateStressPlot() {
            const ctx = stressGradientCanvas;
            const canvas = ctx.canvas;
            
            // Limpar canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Obter valores dos controles
            const density = parseFloat(document.getElementById('density-slider').value);
            document.getElementById('density-value').textContent = density + ' kg/m¬≥';
            
            const tectonic = document.getElementById('tectonic-regime').value;
            
            // Configurar margens e escalas
            const margin = {top: 30, right: 40, bottom: 60, left: 60};
            const width = canvas.width - margin.left - margin.right;
            const height = canvas.height - margin.top - margin.bottom;
            
            const maxDepth = 3000; // metros
            const maxStress = 80; // MPa
            
            // Fun√ß√£o para converter valores para coordenadas
            function xScale(stress) {
                return margin.left + (stress / maxStress) * width;
            }
            
            function yScale(depth) {
                return margin.top + (depth / maxDepth) * height;
            }
            
            // Desenhar t√≠tulo
            ctx.fillStyle = '#333';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Gradientes de Tens√£o vs. Profundidade', canvas.width/2, 20);
            
            // Desenhar eixos
            ctx.beginPath();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, margin.top + height);
            ctx.lineTo(margin.left + width, margin.top + height);
            ctx.stroke();
            
            // R√≥tulos dos eixos
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Tens√£o/Press√£o (MPa)', margin.left + width/2, canvas.height - 15);
            
            ctx.save();
            ctx.translate(15, margin.top + height/2);
            ctx.rotate(-Math.PI/2);
            ctx.textAlign = 'center';
            ctx.fillText('Profundidade (m)', 0, 0);
            ctx.restore();
            
            // Calcular gradientes com base no regime tect√¥nico
            const svGradient = (density * 9.81) / 1000000; // MPa/m = 9.81 * densidade em kg/m¬≥ / 10^6
            
            let shminGradient, shmaxGradient;
            
            switch(tectonic) {
                case 'normal':
                    shminGradient = svGradient * 0.6;
                    shmaxGradient = svGradient * 0.85;
                    document.getElementById('tectonic-value').textContent = 'Normal';
                    break;
                case 'strike-slip':
                    shminGradient = svGradient * 0.7;
                    shmaxGradient = svGradient * 1.2;
                    document.getElementById('tectonic-value').textContent = 'Transcorrente';
                    break;
                case 'reverse':
                    shminGradient = svGradient * 1.1;
                    shmaxGradient = svGradient * 1.5;
                    document.getElementById('tectonic-value').textContent = 'Reverso';
                    break;
                default:
                    shminGradient = svGradient * 0.6;
                    shmaxGradient = svGradient * 0.85;
                    document.getElementById('tectonic-value').textContent = 'Normal';
            }
            
            const ppGradient = 0.01; // 10 MPa/km
            
            // Desenhar linhas de gradiente
            const gradients = [
                {name: 'œÉv', color: '#1f77b4', value: svGradient},
                {name: 'œÉHmax', color: '#ff7f0e', value: shmaxGradient},
                {name: 'œÉhmin', color: '#2ca02c', value: shminGradient},
                {name: 'Pp', color: '#d62728', value: ppGradient}
            ];
            
            gradients.forEach(g => {
                ctx.beginPath();
                ctx.strokeStyle = g.color;
                ctx.lineWidth = 3;
                
                // Desenhar linha de gradiente
                ctx.moveTo(xScale(0), yScale(0));
                ctx.lineTo(xScale(g.value * maxDepth), yScale(maxDepth));
                ctx.stroke();
                
                // Legenda
                ctx.fillStyle = g.color;
                ctx.textAlign = 'left';
                const legendY = margin.top + 25 * (gradients.indexOf(g) + 1);
                ctx.fillText(g.name + ' (' + (g.value * 1000).toFixed(1) + ' kPa/m)', margin.left + width - 150, legendY);
                
                // Linha da legenda
                ctx.beginPath();
                ctx.strokeStyle = g.color;
                ctx.lineWidth = 3;
                ctx.moveTo(margin.left + width - 180, legendY - 4);
                ctx.lineTo(margin.left + width - 160, legendY - 4);
                ctx.stroke();
            });
            
            // Desenhar marca√ß√µes nos eixos
            ctx.fillStyle = '#333';
            ctx.textAlign = 'right';
            ctx.font = '12px Arial';
            
            for (let d = 0; d <= maxDepth; d += 500) {
                ctx.fillText(d.toString(), margin.left - 10, yScale(d) + 4);
                
                // Linhas de grade
                ctx.beginPath();
                ctx.strokeStyle = '#ccc';
                ctx.setLineDash([2, 2]);
                ctx.moveTo(margin.left, yScale(d));
                ctx.lineTo(margin.left + width, yScale(d));
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            ctx.textAlign = 'center';
            for (let s = 0; s <= maxStress; s += 20) {
                ctx.fillText(s.toString(), xScale(s), margin.top + height + 15);
                
                // Linhas de grade
                ctx.beginPath();
                ctx.strokeStyle = '#ccc';
                ctx.setLineDash([2, 2]);
                ctx.moveTo(xScale(s), margin.top);
                ctx.lineTo(xScale(s), margin.top + height);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        // Fun√ß√£o para atualizar mapa de tens√µes
        function updateStressMap() {
            const ctx = stressDistributionMap;
            const canvas = ctx.canvas;
            
            // Limpar canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Obter tipo de visualiza√ß√£o
            const viewType = document.getElementById('stress-view-type').value;
            
            // Desenhar um mapa 2D colorido simulado
            const width = canvas.width;
            const height = canvas.height;
            
            // Simular dados
            const gridSize = 20;
            const cellWidth = width / gridSize;
            const cellHeight = height / gridSize;
            
            let stressField = [];
            let maxStress = 0;
            let minStress = Infinity;
            
            // Criar campo de tens√£o simulado
            for (let y = 0; y < gridSize; y++) {
                stressField[y] = [];
                for (let x = 0; x < gridSize; x++) {
                    // Simular diferentes componentes de tens√£o
                    let stress;
                    
                    // Adicionar algumas caracter√≠sticas geol√≥gicas
                    const featureX = Math.abs(x - gridSize * 0.75) / (gridSize * 0.5);
                    const featureY = Math.abs(y - gridSize * 0.5) / (gridSize * 0.5);
                    
                    const feature = Math.min(1, Math.sqrt(featureX * featureX + featureY * featureY));
                    
                    // Diferentes campos para diferentes visualiza√ß√µes
                    switch(viewType) {
                        case 'sv':
                            stress = 40 + 5 * Math.sin(x/3) + 7 * Math.cos(y/2) + 10 * (1 - feature);
                            break;
                        case 'shmin':
                            stress = 25 + 3 * Math.sin(x/2) + 4 * Math.cos(y/3) + 7 * (1 - feature);
                            break;
                        case 'shmax':
                            stress = 35 + 4 * Math.sin(x/2.5) + 5 * Math.cos(y/2.5) + 8 * (1 - feature);
                            break;
                        case 'diff':
                            const sv = 40 + 5 * Math.sin(x/3) + 7 * Math.cos(y/2) + 10 * (1 - feature);
                            const shmin = 25 + 3 * Math.sin(x/2) + 4 * Math.cos(y/3) + 7 * (1 - feature);
                            stress = sv - shmin;
                            break;
                        default:
                            stress = 30 + 5 * Math.sin(x/3) + 7 * Math.cos(y/2);
                    }
                    
                    stressField[y][x] = stress;
                    maxStress = Math.max(maxStress, stress);
                    minStress = Math.min(minStress, stress);
                }
            }
            
            // Desenhar c√©lulas coloridas
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const stress = stressField[y][x];
                    const normalizedStress = (stress - minStress) / (maxStress - minStress);
                    
                    // Escolher cor com base no valor normalizado
                    let color;
                    if (viewType === 'diff') {
                        // Escala vermelho-amarelo-verde para tens√£o diferencial
                        const r = Math.min(255, Math.round(255 * normalizedStress));
                        const g = Math.min(255, Math.round(255 * (1 - normalizedStress)));
                        const b = 0;
                        color = `rgb(${r}, ${g}, ${b})`;
                    } else {
                        // Escala azul para tens√µes
                        const intensity = Math.round(255 * normalizedStress);
                        color = `rgb(${255-intensity}, ${255-intensity}, 255)`;
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                    
                    // Adicionar contorno
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.strokeRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                }
            }
            
            // Adicionar legenda de cores
            const legendWidth = 30;
            const legendHeight = height * 0.8;
            const legendX = width - legendWidth - 20;
            const legendY = height * 0.1;
            
            for (let i = 0; i < legendHeight; i++) {
                const normalizedValue = 1 - i / legendHeight;
                
                let color;
                if (viewType === 'diff') {
                    const r = Math.min(255, Math.round(255 * normalizedValue));
                    const g = Math.min(255, Math.round(255 * (1 - normalizedValue)));
                    const b = 0;
                    color = `rgb(${r}, ${g}, ${b})`;
                } else {
                    const intensity = Math.round(255 * normalizedValue);
                    color = `rgb(${255-intensity}, ${255-intensity}, 255)`;
                }
                
                ctx.fillStyle = color;
                ctx.fillRect(legendX, legendY + i, legendWidth, 1);
            }
            
            // Contorno da legenda
            ctx.strokeStyle = '#333';
            ctx.strokeRect(legendX, legendY, legendWidth, legendHeight);
            
            // Valores da legenda
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(maxStress.toFixed(0) + ' MPa', legendX - 5, legendY + 12);
            ctx.fillText(minStress.toFixed(0) + ' MPa', legendX - 5, legendY + legendHeight);
            
            // T√≠tulo do mapa
            let title;
            switch(viewType) {
                case 'sv':
                    title = 'Tens√£o Vertical (œÉv)';
                    break;
                case 'shmin':
                    title = 'Tens√£o Horizontal M√≠nima (œÉhmin)';
                    break;
                case 'shmax':
                    title = 'Tens√£o Horizontal M√°xima (œÉHmax)';
                    break;
                case 'diff':
                    title = 'Tens√£o Diferencial (œÉ1-œÉ3)';
                    break;
                default:
                    title = 'Campo de Tens√µes';
            }
            
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(title, width/2, 20);
            
            // Adicionar elementos de reservat√≥rio
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            // Topo do reservat√≥rio
            ctx.beginPath();
            ctx.moveTo(width * 0.1, height * 0.3);
            ctx.bezierCurveTo(
                width * 0.3, height * 0.35,
                width * 0.7, height * 0.25,
                width * 0.9, height * 0.3
            );
            ctx.stroke();
            
            // Base do reservat√≥rio
            ctx.beginPath();
            ctx.moveTo(width * 0.1, height * 0.7);
            ctx.bezierCurveTo(
                width * 0.3, height * 0.65,
                width * 0.7, height * 0.75,
                width * 0.9, height * 0.7
            );
            ctx.stroke();
            
            // Adicionar po√ßos
            ctx.setLineDash([]);
            ctx.lineWidth = 3;
            
            // Po√ßo injetor
            ctx.strokeStyle = '#1E88E5';
            ctx.beginPath();
            ctx.moveTo(width * 0.3, 0);
            ctx.lineTo(width * 0.3, height * 0.5);
            ctx.stroke();
            
            // Perfora√ß√£o
            ctx.strokeStyle = '#1565C0';
            ctx.beginPath();
            ctx.moveTo(width * 0.3, height * 0.5);
            ctx.lineTo(width * 0.4, height * 0.55);
            ctx.stroke();
            
            // Po√ßo produtor
            ctx.strokeStyle = '#E53935';
            ctx.beginPath();
            ctx.moveTo(width * 0.7, 0);
            ctx.lineTo(width * 0.7, height * 0.45);
            ctx.stroke();
            
            // Perfora√ß√£o
            ctx.strokeStyle = '#C62828';
            ctx.beginPath();
            ctx.moveTo(width * 0.7, height * 0.45);
            ctx.lineTo(width * 0.6, height * 0.5);
            ctx.stroke();
            
            // Adicionar r√≥tulos
            ctx.font = '12px Arial';
            ctx.fillStyle = '#1565C0';
            ctx.textAlign = 'center';
            ctx.fillText('Injetor', width * 0.3, 15);
            
            ctx.fillStyle = '#C62828';
            ctx.fillText('Produtor', width * 0.7, 15);
        }
        
        // Fun√ß√£o para atualizar plot de press√£o de poros
        function updatePorePressurePlot() {
            const ctx = porePressureCanvas;
            const canvas = ctx.canvas;
            
            // Limpar canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Obter valores dos controles
            const ppGradient = parseFloat(document.getElementById('pp-gradient-slider').value) / 1000; // MPa/m
            document.getElementById('pp-gradient-value').textContent = (ppGradient * 1000).toFixed(1) + ' kPa/m';
            
            const injectionPercent = parseInt(document.getElementById('injection-slider').value);
            document.getElementById('injection-value').textContent = injectionPercent + '%';
            
            // Configurar margens e escalas
            const margin = {top: 30, right: 40, bottom: 60, left: 60};
            const width = canvas.width - margin.left - margin.right;
            const height = canvas.height - margin.top - margin.bottom;
            
            const maxDepth = 3000; // metros
            const maxPressure = 60; // MPa
            
            // Fun√ß√£o para converter valores para coordenadas
            function xScale(pressure) {
                return margin.left + (pressure / maxPressure) * width;
            }
            
            function yScale(depth) {
                return margin.top + (depth / maxDepth) * height;
            }
            
            // Desenhar t√≠tulo
            ctx.fillStyle = '#333';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Evolu√ß√£o da Press√£o de Poros Durante Inje√ß√£o', canvas.width/2, 20);
            
            // Desenhar eixos
            ctx.beginPath();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, margin.top + height);
            ctx.lineTo(margin.left + width, margin.top + height);
            ctx.stroke();
            
            // R√≥tulos dos eixos
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Press√£o (MPa)', margin.left + width/2, canvas.height - 15);
            
            ctx.save();
            ctx.translate(15, margin.top + height/2);
            ctx.rotate(-Math.PI/2);
            ctx.textAlign = 'center';
            ctx.fillText('Profundidade (m)', 0, 0);
            ctx.restore();
            
            // Calcular press√µes para v√°rias etapas de inje√ß√£o
            const steps = [
                {name: 'Press√£o Hidrost√°tica', color: '#2ca02c', percent: 0},
                {name: 'Inje√ß√£o 25%', color: '#9467bd', percent: 25, dash: [5, 5]},
                {name: 'Inje√ß√£o 50%', color: '#8c564b', percent: 50, dash: [5, 5]},
                {name: 'Inje√ß√£o 75%', color: '#e377c2', percent: 75, dash: [5, 5]},
                {name: 'Inje√ß√£o 100%', color: '#d62728', percent: 100}
            ];
            
            // M√°ximo de inje√ß√£o em MPa aos 2000m de profundidade
            const maxInjection = 20;
            
            steps.forEach(step => {
                ctx.beginPath();
                ctx.strokeStyle = step.color;
                ctx.lineWidth = 3;
                
                if (step.dash) {
                    ctx.setLineDash(step.dash);
                } else {
                    ctx.setLineDash([]);
                }
                
                // Desenhar linha de press√£o
                for (let depth = 0; depth <= maxDepth; depth += 50) {
                    // Press√£o hidrost√°tica base
                    const baseP = ppGradient * depth;
                    
                    // Adicionar incremento de press√£o por inje√ß√£o
                    // Usando uma fun√ß√£o que varia com a profundidade e tem m√°ximo em 2000m
                    const depthFactor = 1 - Math.abs(depth - 2000) / 2000;
                    const injectionP = (maxInjection * step.percent / 100) * Math.max(0, depthFactor);
                    
                    const totalP = baseP + injectionP;
                    
                    if (depth === 0) {
                        ctx.moveTo(xScale(totalP), yScale(depth));
                    } else {
                        ctx.lineTo(xScale(totalP), yScale(depth));
                    }
                }
                
                ctx.stroke();
                
                // Legenda
                ctx.fillStyle = step.color;
                ctx.textAlign = 'left';
                const legendY = margin.top + 25 * (steps.indexOf(step) + 1);
                ctx.fillText(step.name, margin.left + width - 150, legendY);
                
                // Linha da legenda
                ctx.beginPath();
                ctx.strokeStyle = step.color;
                if (step.dash) {
                    ctx.setLineDash(step.dash);
                } else {
                    ctx.setLineDash([]);
                }
                ctx.moveTo(margin.left + width - 180, legendY - 4);
                ctx.lineTo(margin.left + width - 160, legendY - 4);
                ctx.stroke();
                ctx.setLineDash([]);
            });
            
            // Destacar a linha para o valor atual do slider
            ctx.beginPath();
            ctx.strokeStyle = '#ff7f0e';
            ctx.lineWidth = 4;
            ctx.setLineDash([]);
            
            for (let depth = 0; depth <= maxDepth; depth += 50) {
                const baseP = ppGradient * depth;
                const depthFactor = 1 - Math.abs(depth - 2000) / 2000;
                const injectionP = (maxInjection * injectionPercent / 100) * Math.max(0, depthFactor);
                const totalP = baseP + injectionP;
                
                if (depth === 0) {
                    ctx.moveTo(xScale(totalP), yScale(depth));
                } else {
                    ctx.lineTo(xScale(totalP), yScale(depth));
                }
            }
            
            ctx.stroke();
            
            // Adicionar r√≥tulo para linha destacada
            ctx.fillStyle = '#ff7f0e';
            ctx.textAlign = 'left';
            ctx.fillText(`Inje√ß√£o Atual (${injectionPercent}%)`, margin.left + width - 150, margin.top + 25 * (steps.length + 1));
            
            // Linha da legenda
            ctx.beginPath();
            ctx.strokeStyle = '#ff7f0e';
            ctx.lineWidth = 4;
            ctx.moveTo(margin.left + width - 180, margin.top + 25 * (steps.length + 1) - 4);
            ctx.lineTo(margin.left + width - 160, margin.top + 25 * (steps.length + 1) - 4);
            ctx.stroke();
            
            // Desenhar marca√ß√µes nos eixos
            ctx.fillStyle = '#333';
            ctx.textAlign = 'right';
            ctx.font = '12px Arial';
            
            for (let d = 0; d <= maxDepth; d += 500) {
                ctx.fillText(d.toString(), margin.left - 10, yScale(d) + 4);
                
                // Linhas de grade
                ctx.beginPath();
                ctx.strokeStyle = '#ccc';
                ctx.setLineDash([2, 2]);
                ctx.moveTo(margin.left, yScale(d));
                ctx.lineTo(margin.left + width, yScale(d));
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            ctx.textAlign = 'center';
            for (let p = 0; p <= maxPressure; p += 10) {
                ctx.fillText(p.toString(), xScale(p), margin.top + height + 15);
                
                // Linhas de grade
                ctx.beginPath();
                ctx.strokeStyle = '#ccc';
                ctx.setLineDash([2, 2]);
                ctx.moveTo(xScale(p), margin.top);
                ctx.lineTo(xScale(p), margin.top + height);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Marcar zona de reservat√≥rio
            ctx.fillStyle = 'rgba(255, 255, 0, 0.1)';
            ctx.fillRect(margin.left, yScale(1800), width, yScale(2200) - yScale(1800));
            
            // R√≥tulo de reservat√≥rio
            ctx.fillStyle = '#333';
            ctx.textAlign = 'center';
            ctx.font = 'italic 12px Arial';
            ctx.fillText('Zona de Reservat√≥rio', margin.left + width/2, yScale(2000) + 4);
        }
        
        // Fun√ß√£o para atualizar mapa de press√£o
        function updatePressureMap() {
            const ctx = pressureDistributionMap;
            const canvas = ctx.canvas;
            
            // Limpar canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Obter tipo de visualiza√ß√£o (tempo)
            const timePoint = document.getElementById('pressure-time').value;
            
            // Desenhar um mapa 2D colorido simulado
            const width = canvas.width;
            const height = canvas.height;
            
            // Simular dados
            const gridSize = 20;
            const cellWidth = width / gridSize;
            const cellHeight = height / gridSize;
            
            let pressureField = [];
            let maxPressure = 0;
            let minPressure = Infinity;
            
            // Criar campo de press√£o simulado com pluma de inje√ß√£o
            for (let y = 0; y < gridSize; y++) {
                pressureField[y] = [];
                for (let x = 0; x < gridSize; x++) {
                    // Press√£o base do reservat√≥rio
                    let pressure = 25 + 2 * Math.sin(x/5) + 3 * Math.cos(y/4);
                    
                    // Adicionar pluma de inje√ß√£o
                    const injectX = gridSize * 0.3;
                    const injectY = gridSize * 0.5;
                    const dx = x - injectX;
                    const dy = y - injectY;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    let injectionFactor;
                    switch(timePoint) {
                        case 'initial':
                            injectionFactor = 0;
                            break;
                        case 'mid':
                            injectionFactor = 0.5;
                            break;
                        case 'final':
                            injectionFactor = 1.0;
                            break;
                        default:
                            injectionFactor = 0;
                    }
                    
                    // Efeito da inje√ß√£o diminui com a dist√¢ncia
                    const maxRadius = gridSize * 0.6;
                    const injectionEffect = injectionFactor * 20 * Math.max(0, 1 - distance / maxRadius);
                    
                    pressure += injectionEffect;
                    
                    pressureField[y][x] = pressure;
                    maxPressure = Math.max(maxPressure, pressure);
                    minPressure = Math.min(minPressure, pressure);
                }
            }
            
            // Desenhar c√©lulas coloridas
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const pressure = pressureField[y][x];
                    const normalizedPressure = (pressure - minPressure) / (maxPressure - minPressure);
                    
                    // Usar escala de cores que vai de azul (baixa) para vermelho (alta)
                    let r, g, b;
                    
                    if (normalizedPressure < 0.5) {
                        // Azul para verde
                        r = Math.round(0);
                        g = Math.round(normalizedPressure * 2 * 255);
                        b = Math.round((1 - normalizedPressure * 2) * 255);
                    } else {
                        // Verde para vermelho
                        r = Math.round((normalizedPressure - 0.5) * 2 * 255);
                        g = Math.round((1 - (normalizedPressure - 0.5) * 2) * 255);
                        b = 0;
                    }
                    
                    const color = `rgb(${r}, ${g}, ${b})`;
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                    
                    // Adicionar contorno
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.strokeRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                }
            }
            
            // Adicionar legenda de cores
            const legendWidth = 30;
            const legendHeight = height * 0.8;
            const legendX = width - legendWidth - 20;
            const legendY = height * 0.1;
            
            const gradientColors = [
                {pos: 0, color: 'rgb(0, 0, 255)'},      // Azul
                {pos: 0.5, color: 'rgb(0, 255, 0)'},    // Verde
                {pos: 1, color: 'rgb(255, 0, 0)'}       // Vermelho
            ];
            
            for (let i = 0; i < legendHeight; i++) {
                const normalizedValue = 1 - i / legendHeight;
                
                // Encontrar cores para interpolar
                let startColor, endColor, localPos;
                
                if (normalizedValue < 0.5) {
                    startColor = {r: 0, g: 0, b: 255};
                    endColor = {r: 0, g: 255, b: 0};
                    localPos = normalizedValue / 0.5;
                } else {
                    startColor = {r: 0, g: 255, b: 0};
                    endColor = {r: 255, g: 0, b: 0};
                    localPos = (normalizedValue - 0.5) / 0.5;
                }
                
                // Interpolar cores
                const r = Math.round(startColor.r + (endColor.r - startColor.r) * localPos);
                const g = Math.round(startColor.g + (endColor.g - startColor.g) * localPos);
                const b = Math.round(startColor.b + (endColor.b - startColor.b) * localPos);
                
                const color = `rgb(${r}, ${g}, ${b})`;
                
                ctx.fillStyle = color;
                ctx.fillRect(legendX, legendY + i, legendWidth, 1);
            }
            
            // Contorno da legenda
            ctx.strokeStyle = '#333';
            ctx.strokeRect(legendX, legendY, legendWidth, legendHeight);
            
            // Valores da legenda
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(maxPressure.toFixed(0) + ' MPa', legendX - 5, legendY + 12);
            ctx.fillText(minPressure.toFixed(0) + ' MPa', legendX - 5, legendY + legendHeight);
            
            // T√≠tulo do mapa
            let title;
            switch(timePoint) {
                case 'initial':
                    title = 'Press√£o Inicial do Reservat√≥rio';
                    break;
                case 'mid':
                    title = 'Press√£o Durante Inje√ß√£o (50%)';
                    break;
                case 'final':
                    title = 'Press√£o Ap√≥s Inje√ß√£o (100%)';
                    break;
                default:
                    title = 'Campo de Press√£o';
            }
            
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(title, width/2, 20);
            
            // Adicionar po√ßos
            ctx.lineWidth = 3;
            ctx.setLineDash([]);
            
            // Po√ßo injetor
            ctx.strokeStyle = '#1E88E5';
            ctx.beginPath();
            ctx.arc(width * 0.3, height * 0.5, 10, 0, Math.PI * 2);
            ctx.stroke();
            
            // Po√ßo produtor
            ctx.strokeStyle = '#E53935';
            ctx.beginPath();
            ctx.arc(width * 0.7, height * 0.5, 10, 0, Math.PI * 2);
            ctx.stroke();
            
            // Adicionar r√≥tulos
            ctx.font = '12px Arial';
            ctx.fillStyle = '#1565C0';
            ctx.textAlign = 'center';
            ctx.fillText('Injetor', width * 0.3, height * 0.5 - 15);
            
            ctx.fillStyle = '#C62828';
            ctx.fillText('Produtor', width * 0.7, height * 0.5 - 15);
        }
        
        // Fun√ß√£o para atualizar plot de efeito poroel√°stico
        function updatePoroelasticPlot() {
            const ctx = poroelasticCanvas;
            const canvas = ctx.canvas;
            
            // Limpar canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Obter valores dos controles
            const biot = parseFloat(document.getElementById('biot-slider').value);
            document.getElementById('biot-value').textContent = biot.toFixed(2);
            
            const poisson = parseFloat(document.getElementById('poisson-slider').value);
            document.getElementById('poisson-value').textContent = poisson.toFixed(2);
            
            const deltaP = parseFloat(document.getElementById('deltap-slider').value);
            document.getElementById('deltap-value').textContent = deltaP.toFixed(0) + ' MPa';
            
            // Configurar margens e escalas
            const margin = {top: 30, right: 40, bottom: 60, left: 60};
            const width = canvas.width - margin.left - margin.right;
            const height = canvas.height - margin.top - margin.bottom;
            
            // Calcular fator poroel√°stico
            const poroFactor = (biot/3) * (1 + poisson)/(1 - poisson);
            
            // Configurar escala de eixos
            const maxDP = 30; // MPa
            const maxEffect = 15; // MPa
            
            // Fun√ß√£o para converter valores para coordenadas
            function xScale(dp) {
                return margin.left + (dp / maxDP) * width;
            }
            
            function yScale(effect) {
                return margin.top + height - (effect / maxEffect) * height;
            }
            
            // Desenhar t√≠tulo
            ctx.fillStyle = '#333';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Efeito Poroel√°stico em Fun√ß√£o da Varia√ß√£o de Press√£o', canvas.width/2, 20);
            
            // Desenhar eixos
            ctx.beginPath();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, margin.top + height);
            ctx.lineTo(margin.left + width, margin.top + height);
            ctx.stroke();
            
            // R√≥tulos dos eixos
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Varia√ß√£o de Press√£o de Poros (MPa)', margin.left + width/2, canvas.height - 15);
            
            ctx.save();
            ctx.translate(15, margin.top + height/2);
            ctx.rotate(-Math.PI/2);
            ctx.textAlign = 'center';
            ctx.fillText('Varia√ß√£o na Tens√£o (MPa)', 0, 0);
            ctx.restore();
            
            // Desenhar linha de efeito poroel√°stico
            ctx.beginPath();
            ctx.strokeStyle = '#1f77b4';
            ctx.lineWidth = 3;
            
            for (let dp = 0; dp <= maxDP; dp++) {
                const effect = poroFactor * dp;
                
                if (dp === 0) {
                    ctx.moveTo(xScale(dp), yScale(effect));
                } else {
                    ctx.lineTo(xScale(dp), yScale(effect));
                }
            }
            
            ctx.stroke();
            
            // Desenhar ponto para o valor atual
            const currentEffect = poroFactor * deltaP;
            
            ctx.beginPath();
            ctx.fillStyle = '#ff7f0e';
            ctx.arc(xScale(deltaP), yScale(currentEffect), 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Adicionar r√≥tulo ao ponto
            ctx.fillStyle = '#333';
            ctx.textAlign = 'left';
            ctx.font = '12px Arial';
            ctx.fillText(`ŒîP = ${deltaP} MPa`, xScale(deltaP) + 10, yScale(currentEffect) - 5);
            ctx.fillText(`ŒîœÉ = ${currentEffect.toFixed(2)} MPa`, xScale(deltaP) + 10, yScale(currentEffect) + 15);
            
            // Desenhar marca√ß√µes nos eixos
            ctx.fillStyle = '#333';
            ctx.textAlign = 'right';
            ctx.font = '12px Arial';
            
            for (let e = 0; e <= maxEffect; e += 3) {
                ctx.fillText(e.toString(), margin.left - 10, yScale(e) + 4);
                
                // Linhas de grade
                ctx.beginPath();
                ctx.strokeStyle = '#ccc';
                ctx.setLineDash([2, 2]);
                ctx.moveTo(margin.left, yScale(e));
                ctx.lineTo(margin.left + width, yScale(e));
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            ctx.textAlign = 'center';
            for (let p = 0; p <= maxDP; p += 5) {
                ctx.fillText(p.toString(), xScale(p), margin.top + height + 15);
                
                // Linhas de grade
                ctx.beginPath();
                ctx.strokeStyle = '#ccc';
                ctx.setLineDash([2, 2]);
                ctx.moveTo(xScale(p), margin.top);
                ctx.lineTo(xScale(p), margin.top + height);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Adicionar equa√ß√£o
            ctx.fillStyle = '#333';
            ctx.font = 'italic 14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Fator Poroel√°stico = (Œ±/3) √ó (1+ŒΩ)/(1-ŒΩ) = ${poroFactor.toFixed(3)}`, margin.left + 20, margin.top + 30);
            
            // Adicionar legenda de equa√ß√£o
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            const legendY = margin.top + 60;
            ctx.fillText(`Œ± = Coef. Biot = ${biot.toFixed(2)}`, margin.left + 20, legendY);
            ctx.fillText(`ŒΩ = Raz√£o de Poisson = ${poisson.toFixed(2)}`, margin.left + 20, legendY + 20);
            
            // Adicionar linha de explica√ß√£o
            ctx.fillStyle = '#d62728';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('Importante: Este √© o efeito de transfer√™ncia de tens√£o!', margin.left + 20, legendY + 50);
            
            // Compara√ß√£o com Terzaghi (sem efeito poroel√°stico)
            ctx.beginPath();
            ctx.strokeStyle = '#d62728';
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 2;
            
            ctx.moveTo(xScale(0), yScale(0));
            ctx.lineTo(xScale(maxDP), yScale(0));
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#333';
            ctx.font = 'italic 12px Arial';
            ctx.fillText('Teoria cl√°ssica de Terzaghi (sem efeito poroel√°stico)', xScale(maxDP) - 300, yScale(0) - 5);
        }
        
        // Fun√ß√£o para atualizar mapa de efeito poroel√°stico
        function updatePoroelasticMap() {
            const ctx = poroelasticMap;
            const canvas = ctx.canvas;
            
            // Limpar canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Obter tipo de visualiza√ß√£o
            const component = document.getElementById('poroelastic-component').value;
            
            // Obter valores dos controles
            const biot = parseFloat(document.getElementById('biot-slider').value);
            const poisson = parseFloat(document.getElementById('poisson-slider').value);
            
            // Desenhar um mapa 2D colorido simulado
            const width = canvas.width;
            const height = canvas.height;
            
            // Simular dados
            const gridSize = 20;
            const cellWidth = width / gridSize;
            const cellHeight = height / gridSize;
            
            let effectField = [];
            let maxEffect = 0;
            let minEffect = 0;
            
            // Calcular fator poroel√°stico
            const poroFactor = (biot/3) * (1 + poisson)/(1 - poisson);
            
            // Criar campo de press√£o simulado com pluma de inje√ß√£o
            for (let y = 0; y < gridSize; y++) {
                effectField[y] = [];
                for (let x = 0; x < gridSize; x++) {
                    // Press√£o base e incremento
                    const baseP = 25;
                    
                    // Adicionar pluma de inje√ß√£o
                    const injectX = gridSize * 0.3;
                    const injectY = gridSize * 0.5;
                    const dx = x - injectX;
                    const dy = y - injectY;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // Efeito da inje√ß√£o diminui com a dist√¢ncia
                    const maxRadius = gridSize * 0.6;
                    const deltaP = 20 * Math.max(0, 1 - distance / maxRadius);
                    
                    // Efeito poroel√°stico
                    let effect;
                    
                    switch(component) {
                        case 'dshmin':
                            effect = poroFactor * deltaP;
                            break;
                        case 'dshmax':
                            effect = poroFactor * deltaP;
                            break;
                        case 'dsv':
                            // Assumindo deforma√ß√£o uniaxial
                            effect = poroFactor * deltaP * 0.7;
                            break;
                        case 'factor':
                            effect = poroFactor;
                            break;
                        default:
                            effect = poroFactor * deltaP;
                    }
                    
                    effectField[y][x] = effect;
                    maxEffect = Math.max(maxEffect, effect);
                    minEffect = Math.min(minEffect, effect);
                }
            }
            
            // Ajustar escala para o fator
            if (component === 'factor') {
                minEffect = 0;
                maxEffect = poroFactor * 1.1;
                
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        effectField[y][x] = poroFactor;
                    }
                }
            }
            
            // Desenhar c√©lulas coloridas
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const effect = effectField[y][x];
                    const normalizedEffect = (effect - minEffect) / (maxEffect - minEffect);
                    
                    // Usar escala de cores azul-verde-vermelho
                    let r, g, b;
                    
                    if (component === 'factor') {
                        // Escala de cinza para o fator
                        const intensity = Math.round(255 * normalizedEffect);
                        r = g = b = 255 - intensity;
                    } else {
                        if (normalizedEffect < 0.5) {
                            // Azul para verde
                            r = Math.round(0);
                            g = Math.round(normalizedEffect * 2 * 255);
                            b = Math.round((1 - normalizedEffect * 2) * 255);
                        } else {
                            // Verde para vermelho
                            r = Math.round((normalizedEffect - 0.5) * 2 * 255);
                            g = Math.round((1 - (normalizedEffect - 0.5) * 2) * 255);
                            b = 0;
                        }
                    }
                    
                    const color = `rgb(${r}, ${g}, ${b})`;
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                    
                    // Adicionar contorno
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.strokeRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                    
                    // Adicionar valor em algumas c√©lulas
                    if (component === 'factor' && (x + y) % 8 === 0) {
                        ctx.fillStyle = normalizedEffect > 0.5 ? 'white' : 'black';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(effect.toFixed(2), x * cellWidth + cellWidth/2, y * cellHeight + cellHeight/2 + 3);
                    }
                }
            }
            
            // Adicionar legenda de cores
            const legendWidth = 30;
            const legendHeight = height * 0.8;
            const legendX = width - legendWidth - 20;
            const legendY = height * 0.1;
            
            if (component === 'factor') {
                // Escala de cinza para o fator
                for (let i = 0; i < legendHeight; i++) {
                    const normalizedValue = 1 - i / legendHeight;
                    const intensity = Math.round(255 * normalizedValue);
                    const color = `rgb(${255-intensity}, ${255-intensity}, ${255-intensity})`;
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(legendX, legendY + i, legendWidth, 1);
                }
            } else {
                // Escala azul-verde-vermelho 
                for (let i = 0; i < legendHeight; i++) {
                    const normalizedValue = 1 - i / legendHeight;
                    
                    let r, g, b;
                    if (normalizedValue < 0.5) {
                        r = Math.round(0);
                        g = Math.round(normalizedValue * 2 * 255);
                        b = Math.round((1 - normalizedValue * 2) * 255);
                    } else {
                        r = Math.round((normalizedValue - 0.5) * 2 * 255);
                        g = Math.round((1 - (normalizedValue - 0.5) * 2) * 255);
                        b = 0;
                    }
                    
                    const color = `rgb(${r}, ${g}, ${b})`;
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(legendX, legendY + i, legendWidth, 1);
                }
            }
            
            // Contorno da legenda
            ctx.strokeStyle = '#333';
            ctx.strokeRect(legendX, legendY, legendWidth, legendHeight);
            
            // Valores da legenda
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(maxEffect.toFixed(2), legendX - 5, legendY + 12);
            ctx.fillText(minEffect.toFixed(2), legendX - 5, legendY + legendHeight);
            
            // T√≠tulo do mapa
            let title;
            switch(component) {
                case 'dshmin':
                    title = 'Varia√ß√£o em œÉhmin devido ao Efeito Poroel√°stico';
                    break;
                case 'dshmax':
                    title = 'Varia√ß√£o em œÉHmax devido ao Efeito Poroel√°stico';
                    break;
                case 'dsv':
                    title = 'Varia√ß√£o em œÉv devido ao Efeito Poroel√°stico';
                    break;
                case 'factor':
                    title = `Fator Poroel√°stico = ${poroFactor.toFixed(3)}`;
                    break;
                default:
                    title = 'Efeito Poroel√°stico';
            }
            
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(title, width/2, 20);
            
            // Adicionar po√ßo injetor se n√£o for o fator
            if (component !== 'factor') {
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                
                // Po√ßo injetor
                ctx.strokeStyle = '#1E88E5';
                ctx.beginPath();
                ctx.arc(width * 0.3, height * 0.5, 10, 0, Math.PI * 2);
                ctx.stroke();
                
                // Adicionar r√≥tulo
                ctx.font = '12px Arial';
                ctx.fillStyle = '#1565C0';
                ctx.textAlign = 'center';
                ctx.fillText('Injetor', width * 0.3, height * 0.5 - 15);
            } else {
                // Equa√ß√£o do fator poroel√°stico
                ctx.fillStyle = '#333';
                ctx.font = 'italic 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Fator Poroel√°stico = (Œ±/3) √ó (1+ŒΩ)/(1-ŒΩ)`, width/2, height - 20);
                
                ctx.font = '12px Arial';
                ctx.fillText(`Œ± = ${biot.toFixed(2)}, ŒΩ = ${poisson.toFixed(2)}`, width/2, height - 5);
            }
        }
        
        // Fun√ß√£o para atualizar plot de falha tensional
        function updateTensilePlot() {
            const ctx = tensileFailureCanvas;
            const canvas = ctx.canvas;
            
            // Limpar canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Obter valores dos controles
            const shminGradient = parseFloat(document.getElementById('shmin-gradient-slider').value) / 1000; // MPa/m
            document.getElementById('shmin-gradient-value').textContent = (shminGradient * 1000).toFixed(1) + ' kPa/m';
            
            const injectionRate = parseInt(document.getElementById('injection-rate-slider').value);
            document.getElementById('injection-rate-value').textContent = injectionRate + ' m¬≥/dia';
            
            const usePoroelastic = document.getElementById('poroelastic-toggle').checked;
            
            // Configura√ß√£o de poroelasticidade
            const biot = 0.8;
            const poisson = 0.25;
            const poroFactor = (biot/3) * (1 + poisson)/(1 - poisson);
            
            // Configurar margens e escalas
            const margin = {top: 30, right: 40, bottom: 60, left: 60};
            const width = canvas.width - margin.left - margin.right;
            const height = canvas.height - margin.top - margin.bottom;
            
            const maxDepth = 3000; // metros
            const maxPressure = 60; // MPa
            
            // Fun√ß√£o para converter valores para coordenadas
            function xScale(pressure) {
                return margin.left + (pressure / maxPressure) * width;
            }
            
            function yScale(depth) {
                return margin.top + (depth / maxDepth) * height;
            }
            
            // Desenhar t√≠tulo
            ctx.fillStyle = '#333';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('An√°lise de Fraturamento Hidr√°ulico com Efeitos Poroel√°sticos', canvas.width/2, 20);
            
            // Desenhar eixos
            ctx.beginPath();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, margin.top + height);
            ctx.lineTo(margin.left + width, margin.top + height);
            ctx.stroke();
            
            // R√≥tulos dos eixos
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Press√£o (MPa)', margin.left + width/2, canvas.height - 15);
            
            ctx.save();
            ctx.translate(15, margin.top + height/2);
            ctx.rotate(-Math.PI/2);
            ctx.textAlign = 'center';
            ctx.fillText('Profundidade (m)', 0, 0);
            ctx.restore();
            
            // Gradiente de press√£o de poros inicial
            const ppGradient = 0.01; // 10 MPa/km
            
            // Desenhar linhas
            const lines = [
                {name: 'Press√£o Hidrost√°tica', color: '#2ca02c', 
                 fn: depth => ppGradient * depth},
                {name: 'Press√£o Inje√ß√£o', color: '#d62728', 
                 fn: depth => {
                    const baseP = ppGradient * depth;
                    const depthFactor = 1 - Math.abs(depth - 2000) / 2000;
                    const maxPressureIncrease = injectionRate / 5; // Simplificado
                    const injectionP = maxPressureIncrease * Math.max(0, depthFactor);
                    return baseP + injectionP;
                 }},
                {name: 'Tens√£o Horizontal M√≠n', color: '#1f77b4', 
                 fn: depth => shminGradient * depth}
            ];
            
            // Adicionar linha poroel√°stica se necess√°rio
            if (usePoroelastic) {
                lines.push({
                    name: 'Press√£o Fratura (com poroelasticidade)', 
                    color: '#ff7f0e',
                    fn: depth => {
                        const shmin = shminGradient * depth;
                        const baseP = ppGradient * depth;
                        
                        // Calcular incremento de press√£o na profundidade
                        const depthFactor = 1 - Math.abs(depth - 2000) / 2000;
                        const maxPressureIncrease = injectionRate / 5; // Simplificado
                        const deltaP = maxPressureIncrease * Math.max(0, depthFactor);
                        
                        // Adicionar efeito poroel√°stico
                        const poroEffect = poroFactor * deltaP;
                        
                        return shmin + poroEffect;
                    }
                });
            }
            
            // Desenhar cada linha
            lines.forEach(line => {
                ctx.beginPath();
                ctx.strokeStyle = line.color;
                ctx.lineWidth = 3;
                
                for (let depth = 0; depth <= maxDepth; depth += 50) {
                    const p = line.fn(depth);
                    
                    if (depth === 0) {
                        ctx.moveTo(xScale(p), yScale(depth));
                    } else {
                        ctx.lineTo(xScale(p), yScale(depth));
                    }
                }
                
                ctx.stroke();
                
                // Legenda
                ctx.fillStyle = line.color;
                ctx.textAlign = 'left';
                const legendY = margin.top + 25 * (lines.indexOf(line) + 1);
                ctx.fillText(line.name, margin.left + width - 250, legendY);
                
                // Linha da legenda
                ctx.beginPath();
                ctx.strokeStyle = line.color;
                ctx.moveTo(margin.left + width - 280, legendY - 4);
                ctx.lineTo(margin.left + width - 260, legendY - 4);
                ctx.stroke();
            });
            
            // Adicionar regi√£o de fraturamento se press√£o de inje√ß√£o > press√£o de fratura
            let intersectionFound = false;
            let intersectionDepth = 0;
            
            for (let depth = 0; depth <= maxDepth; depth += 10) {
                const injP = lines[1].fn(depth); // Press√£o de inje√ß√£o
                let fracP;
                
                if (usePoroelastic) {
                    fracP = lines[3].fn(depth); // Press√£o de fratura com poroelasticidade
                } else {
                    fracP = lines[2].fn(depth); // Tens√£o m√≠nima (sem poroelasticidade)
                }
                
                if (injP > fracP && !intersectionFound) {
                    intersectionFound = true;
                    intersectionDepth = depth;
                    break;
                }
            }
            
            if (intersectionFound) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                ctx.beginPath();
                
                // Encontrar todos os pontos de interse√ß√£o
                let points = [];
                let inside = false;
                
                for (let depth = 0; depth <= maxDepth; depth += 10) {
                    const injP = lines[1].fn(depth); // Press√£o de inje√ß√£o
                    let fracP;
                    
                    if (usePoroelastic) {
                        fracP = lines[3].fn(depth); // Press√£o de fratura com poroelasticidade
                    } else {
                        fracP = lines[2].fn(depth); // Tens√£o m√≠nima (sem poroelasticidade)
                    }
                    
                    if (injP > fracP && !inside) {
                        inside = true;
                        points.push({depth, p: injP});
                    } else if (injP <= fracP && inside) {
                        inside = false;
                        points.push({depth, p: injP});
                    }
                }
                
                // Se estamos dentro no final, adicionar ponto final
                if (inside) {
                    points.push({depth: maxDepth, p: lines[1].fn(maxDepth)});
                }
                
                // Desenhar regi√£o
                if (points.length >= 2) {
                    ctx.beginPath();
                    ctx.moveTo(xScale(points[0].p), yScale(points[0].depth));
                    
                    for (let i = 1; i < points.length; i++) {
                        ctx.lineTo(xScale(points[i].p), yScale(points[i].depth));
                    }
                    
                    // Fechar o pol√≠gono
                    if (usePoroelastic) {
                        for (let i = points.length - 1; i >= 0; i--) {
                            const fracP = lines[3].fn(points[i].depth);
                            ctx.lineTo(xScale(fracP), yScale(points[i].depth));
                        }
                    } else {
                        for (let i = points.length - 1; i >= 0; i--) {
                            const shmin = lines[2].fn(points[i].depth);
                            ctx.lineTo(xScale(shmin), yScale(points[i].depth));
                        }
                    }
                    
                    ctx.closePath();
                    ctx.fill();
                    
                    // Adicionar r√≥tulo
                    ctx.fillStyle = '#d62728';
                    ctx.font = 'bold 14px Arial';
                    
                    // Encontrar centro da regi√£o para colocar o r√≥tulo
                    if (points.length >= 2) {
                        const centerDepth = (points[0].depth + points[points.length-1].depth) / 2;
                        ctx.fillText('Regi√£o de Fraturamento', xScale(lines[1].fn(centerDepth)) - 70, yScale(centerDepth));
                    }
                }
            }
            
            // Desenhar marca√ß√µes nos eixos
            ctx.fillStyle = '#333';
            ctx.textAlign = 'right';
            ctx.font = '12px Arial';
            
            for (let d = 0; d <= maxDepth; d += 500) {
                ctx.fillText(d.toString(), margin.left - 10, yScale(d) + 4);
                
                // Linhas de grade
                ctx.beginPath();
                ctx.strokeStyle = '#ccc';
                ctx.setLineDash([2, 2]);
                ctx.moveTo(margin.left, yScale(d));
                ctx.lineTo(margin.left + width, yScale(d));
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            ctx.textAlign = 'center';
            for (let p = 0; p <= maxPressure; p += 10) {
                ctx.fillText(p.toString(), xScale(p), margin.top + height + 15);
                
                // Linhas de grade
                ctx.beginPath();
                ctx.strokeStyle = '#ccc';
                ctx.setLineDash([2, 2]);
                ctx.moveTo(xScale(p), margin.top);
                ctx.lineTo(xScale(p), margin.top + height);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Adicionar nota sobre efeito poroel√°stico
            if (usePoroelastic) {
                ctx.fillStyle = '#ff7f0e';
                ctx.font = 'italic 12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`Efeito poroel√°stico: ${(poroFactor*100).toFixed(1)}% da varia√ß√£o de press√£o √© transferida para a tens√£o`, 
                             margin.left, margin.top + height + 40);
            } else {
                ctx.fillStyle = '#777';
                ctx.font = 'italic 12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('Efeito poroel√°stico desativado (press√£o de fratura = tens√£o horizontal m√≠nima)', 
                             margin.left, margin.top + height + 40);
            }
        }
        
        // Fun√ß√£o para atualizar mapa de falha tensional
        function updateTensileMap() {
            const ctx = tensileFailureMap;
            const canvas = ctx.canvas;
            
            // Limpar canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Obter tipo de visualiza√ß√£o
            const mapType = document.getElementById('tensile-map-type').value;
            
            // Obter valores dos controles
            const usePoroelastic = document.getElementById('poroelastic-toggle').checked;
            const injectionRate = parseInt(document.getElementById('injection-rate-slider').value);
            
            // Desenhar um mapa 2D colorido simulado
            const width = canvas.width;
            const height = canvas.height;
            
            // Simular dados
            const gridSize = 20;
            const cellWidth = width / gridSize;
            const cellHeight = height / gridSize;
            
            // Configura√ß√£o de poroelasticidade
            const biot = 0.8;
            const poisson = 0.25;
            const poroFactor = usePoroelastic ? (biot/3) * (1 + poisson)/(1 - poisson) : 0;
            
            // Gerar dados de press√£o e tens√£o
            let dataField = [];
            let maxValue = 0;
            let minValue = Infinity;
            
            for (let y = 0; y < gridSize; y++) {
                dataField[y] = [];
                for (let x = 0; x < gridSize; x++) {
                    // Valores base
                    const baseShmin = 25 + 2 * Math.sin(x/5) + 3 * Math.cos(y/4);
                    const basePp = 15 + Math.sin(x/6) + Math.cos(y/5);
                    
                    // Adicionar pluma de inje√ß√£o
                    const injectX = gridSize * 0.3;
                    const injectY = gridSize * 0.5;
                    const dx = x - injectX;
                    const dy = y - injectY;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // Efeito da inje√ß√£o diminui com a dist√¢ncia
                    const maxRadius = gridSize * 0.6;
                    const injectionFactor = Math.max(0, 1 - distance / maxRadius);
                    const injectionP = (injectionRate / 10) * injectionFactor;
                    
                    // Press√£o final
                    const pressure = basePp + injectionP;
                    
                    // Efeito poroel√°stico na tens√£o
                    const poroEffect = poroFactor * injectionP;
                    
                    // Press√£o de fraturamento
                    const fracturePressure = baseShmin + poroEffect;
                    
                    // Fator de seguran√ßa
                    const safetyFactor = fracturePressure / pressure;
                    
                    // Valor a ser exibido com base no tipo de mapa
                    let value;
                    
                    switch(mapType) {
                        case 'pressure':
                            value = pressure;
                            break;
                        case 'frac-pressure':
                            value = fracturePressure;
                            break;
                        case 'sf':
                            value = safetyFactor;
                            break;
                        default:
                            value = safetyFactor;
                    }
                    
                    dataField[y][x] = value;
                    maxValue = Math.max(maxValue, value);
                    minValue = Math.min(minValue, value);
                }
            }
            
            // Ajustar limites para fator de seguran√ßa
            if (mapType === 'sf') {
                minValue = Math.min(minValue, 0.8);
                maxValue = Math.max(maxValue, 1.5);
            }
            
            // Desenhar c√©lulas coloridas
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const value = dataField[y][x];
                    const normalizedValue = (value - minValue) / (maxValue - minValue);
                    
                    // Escolher cor com base no valor
                    let color;
                    
                    if (mapType === 'sf') {
                        // Escala espec√≠fica para fator de seguran√ßa
                        if (value < 1.0) {
                            // Vermelho para SF < 1.0 (falha)
                            color = '#ef4444';
                        } else if (value < 1.2) {
                            // Amarelo para 1.0 <= SF < 1.2 (aten√ß√£o)
                            color = '#f59e0b';
                        } else {
                            // Verde para SF >= 1.2 (seguro)
                            color = '#10b981';
                        }
                    } else {
                        // Escala azul-verde-vermelho para outros casos
                        let r, g, b;
                        
                        if (normalizedValue < 0.5) {
                            // Azul para verde
                            r = Math.round(0);
                            g = Math.round(normalizedValue * 2 * 255);
                            b = Math.round((1 - normalizedValue * 2) * 255);
                        } else {
                            // Verde para vermelho
                            r = Math.round((normalizedValue - 0.5) * 2 * 255);
                            g = Math.round((1 - (normalizedValue - 0.5) * 2) * 255);
                            b = 0;
                        }
                        
                        color = `rgb(${r}, ${g}, ${b})`;
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                    
                    // Adicionar contorno
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.strokeRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                    
                    // Adicionar valor para o fator de seguran√ßa em algumas c√©lulas
                    if (mapType === 'sf' && (x + y) % 6 === 0) {
                        ctx.fillStyle = 'white';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(value.toFixed(2), x * cellWidth + cellWidth/2, y * cellHeight + cellHeight/2 + 3);
                    }
                }
            }
            
            // Adicionar legenda de cores se n√£o for fator de seguran√ßa
            if (mapType !== 'sf') {
                const legendWidth = 30;
                const legendHeight = height * 0.8;
                const legendX = width - legendWidth - 20;
                const legendY = height * 0.1;
                
                const gradientColors = [
                    {pos: 0, color: 'rgb(0, 0, 255)'},      // Azul
                    {pos: 0.5, color: 'rgb(0, 255, 0)'},    // Verde
                    {pos: 1, color: 'rgb(255, 0, 0)'}       // Vermelho
                ];
                
                for (let i = 0; i < legendHeight; i++) {
                    const normalizedValue = 1 - i / legendHeight;
                    
                    // Encontrar cores para interpolar
                    let r, g, b;
                    if (normalizedValue < 0.5) {
                        r = Math.round(0);
                        g = Math.round(normalizedValue * 2 * 255);
                        b = Math.round((1 - normalizedValue * 2) * 255);
                    } else {
                        r = Math.round((normalizedValue - 0.5) * 2 * 255);
                        g = Math.round((1 - (normalizedValue - 0.5) * 2) * 255);
                        b = 0;
                    }
                    
                    const color = `rgb(${r}, ${g}, ${b})`;
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(legendX, legendY + i, legendWidth, 1);
                }
                
                // Contorno da legenda
                ctx.strokeStyle = '#333';
                ctx.strokeRect(legendX, legendY, legendWidth, legendHeight);
                
                // Valores da legenda
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(maxValue.toFixed(1) + (mapType === 'sf' ? '' : ' MPa'), legendX - 5, legendY + 12);
                ctx.fillText(minValue.toFixed(1) + (mapType === 'sf' ? '' : ' MPa'), legendX - 5, legendY + legendHeight);
            }
            
            // T√≠tulo do mapa
            let title;
            switch(mapType) {
                case 'pressure':
                    title = 'Press√£o de Poros Ap√≥s Inje√ß√£o';
                    break;
                case 'frac-pressure':
                    title = 'Press√£o de Fraturamento' + (usePoroelastic ? ' (com efeito poroel√°stico)' : '');
                    break;
                case 'sf':
                    title = 'Fator de Seguran√ßa para Fraturamento Hidr√°ulico';
                    break;
                default:
                    title = 'Campo de Press√£o';
            }
            
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(title, width/2, 20);
            
            // Adicionar po√ßo injetor
            ctx.lineWidth = 3;
            ctx.setLineDash([]);
            
            // Po√ßo injetor
            ctx.strokeStyle = '#1E88E5';
            ctx.beginPath();
            ctx.arc(width * 0.3, height * 0.5, 10, 0, Math.PI * 2);
            ctx.stroke();
            
            // Adicionar r√≥tulo
            ctx.font = '12px Arial';
            ctx.fillStyle = '#1565C0';
            ctx.textAlign = 'center';
            ctx.fillText('Injetor', width * 0.3, height * 0.5 - 15);
            
            // Adicionar informa√ß√£o sobre efeito poroel√°stico
            if (usePoroelastic) {
                ctx.fillStyle = '#333';
                ctx.font = 'italic 12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`Efeito poroel√°stico: ${(poroFactor*100).toFixed(1)}% da varia√ß√£o de press√£o transferida para a tens√£o`, 20, height - 10);
            }
        }
        
        // Fun√ß√£o para atualizar plot de falha por cisalhamento
        function updateShearPlot() {
            const ctx = shearFailureCanvas;
            const canvas = ctx.canvas;
            
            // Limpar canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Obter valores dos controles
            const cohesion = parseFloat(document.getElementById('cohesion-slider').value);
            document.getElementById('cohesion-value').textContent = cohesion + ' MPa';
            
            const frictionAngle = parseInt(document.getElementById('friction-angle-slider').value);
            document.getElementById('friction-angle-value').textContent = frictionAngle + '¬∞';
            
            const stressRatio = parseFloat(document.getElementById('stress-ratio-slider').value);
            document.getElementById('stress-ratio-value').textContent = stressRatio.toFixed(1);
            
            // Configurar margens e escalas
            const margin = {top: 30, right: 40, bottom: 60, left: 60};
            const width = canvas.width - margin.left - margin.right;
            const height = canvas.height - margin.top - margin.bottom;
            
            const maxInjectionP = 50; // MPa
            const maxSF = 3.0;
            
            // Fun√ß√£o para converter valores para coordenadas
            function xScale(pressure) {
                return margin.left + (pressure / maxInjectionP) * width;
            }
            
            function yScale(sf) {
                return margin.top + height - (sf / maxSF) * height;
            }
            
            // Desenhar t√≠tulo
            ctx.fillStyle = '#333';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Fator de Seguran√ßa ao Cisalhamento vs. Press√£o de Inje√ß√£o', canvas.width/2, 20);
            
            // Desenhar eixos
            ctx.beginPath();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, margin.top + height);
            ctx.lineTo(margin.left + width, margin.top + height);
            ctx.stroke();
            
            // R√≥tulos dos eixos
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Press√£o de Inje√ß√£o (MPa)', margin.left + width/2, canvas.height - 15);
            
            ctx.save();
            ctx.translate(15, margin.top + height/2);
            ctx.rotate(-Math.PI/2);
            ctx.textAlign = 'center';
            ctx.fillText('Fator de Seguran√ßa', 0, 0);
            ctx.restore();
            
            // Par√¢metros
            const biot = 0.8;
            const poisson = 0.25;
            const poroFactor = (biot/3) * (1 + poisson)/(1 - poisson);
            const frictionRad = frictionAngle * Math.PI / 180;
            
            // Desenhar curvas para diferentes profundidades
            const depths = [
                {name: '1000 m', color: '#1f77b4', sv: 22, shmin: 14},
                {name: '1500 m', color: '#ff7f0e', sv: 33, shmin: 21},
                {name: '2000 m', color: '#2ca02c', sv: 44, shmin: 28},
                {name: '2500 m', color: '#d62728', sv: 55, shmin: 35}
            ];
            
            depths.forEach(depth => {
                ctx.beginPath();
                ctx.strokeStyle = depth.color;
                ctx.lineWidth = 3;
                
                const sv = depth.sv;
                const shmin = depth.shmin;
                const initialPp = depth.sv * 0.45; // Press√£o inicial = 45% da tens√£o vertical
                
                for (let injP = 0; injP <= maxInjectionP; injP += 0.5) {
                    // C√°lculo do fator de seguran√ßa ao cisalhamento
                    // Press√£o de poros final = press√£o inicial + incremento
                    const finalPp = initialPp + injP;
                    
                    // Efeito poroel√°stico
                    const dsv = poroFactor * injP;
                    const dshmin = poroFactor * injP;
                    
                    // Tens√µes efetivas
                    const svEff = sv + dsv - biot * finalPp;
                    const shminEff = shmin + dshmin - biot * finalPp;
                    
                    // Tens√µes principais (simplificado para regime normal)
                    const s1Eff = svEff;
                    const s3Eff = shminEff;
                    
                    // Cisalhamento atual
                    const diffStress = s1Eff - s3Eff;
                    const shearStress = diffStress / 2;
                    
                    // Tens√£o normal m√©dia
                    const meanStress = (s1Eff + s3Eff) / 2;
                    
                    // Resist√™ncia ao cisalhamento Mohr-Coulomb
                    const shearStrength = cohesion + meanStress * Math.sin(frictionRad);
                    
                    // Fator de seguran√ßa = resist√™ncia / tens√£o atual
                    const sf = shearStrength / shearStress;
                    
                    if (injP === 0) {
                        ctx.moveTo(xScale(injP), yScale(sf));
                    } else {
                        ctx.lineTo(xScale(injP), yScale(sf));
                    }
                }
                
                ctx.stroke();
                
                // Legenda
                ctx.fillStyle = depth.color;
                ctx.textAlign = 'left';
                const legendY = margin.top + 25 * (depths.indexOf(depth) + 1);
                ctx.fillText(depth.name, margin.left + width - 100, legendY);
                
                // Linha da legenda
                ctx.beginPath();
                ctx.strokeStyle = depth.color;
                ctx.moveTo(margin.left + width - 130, legendY - 4);
                ctx.lineTo(margin.left + width - 110, legendY - 4);
                ctx.stroke();
            });
            
            // Linhas de refer√™ncia para fatores de seguran√ßa
            const safetyLines = [
                {sf: 1.0, label: 'SF = 1.0 (Falha)', color: '#ef4444', dash: [5, 5]},
                {sf: 1.2, label: 'SF = 1.2 (Seguran√ßa m√≠nima)', color: '#f59e0b', dash: [5, 5]},
                {sf: 1.5, label: 'SF = 1.5 (Seguran√ßa recomendada)', color: '#10b981', dash: [5, 5]}
            ];
            
            safetyLines.forEach(line => {
                ctx.beginPath();
                ctx.strokeStyle = line.color;
                ctx.lineWidth = 2;
                ctx.setLineDash(line.dash);
                
                ctx.moveTo(xScale(0), yScale(line.sf));
                ctx.lineTo(xScale(maxInjectionP), yScale(line.sf));
                ctx.stroke();
                
                // R√≥tulo
                ctx.fillStyle = line.color;
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(line.label, xScale(maxInjectionP) - 10, yScale(line.sf) - 5);
            });
            
            ctx.setLineDash([]);
            
            // Desenhar marca√ß√µes nos eixos
            ctx.fillStyle = '#333';
            ctx.textAlign = 'right';
            ctx.font = '12px Arial';
            
            for (let sf = 0; sf <= maxSF; sf += 0.5) {
                ctx.fillText(sf.toFixed(1), margin.left - 10, yScale(sf) + 4);
                
                // Linhas de grade
                ctx.beginPath();
                ctx.strokeStyle = '#ccc';
                ctx.setLineDash([2, 2]);
                ctx.moveTo(margin.left, yScale(sf));
                ctx.lineTo(margin.left + width, yScale(sf));
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            ctx.textAlign = 'center';
            for (let p = 0; p <= maxInjectionP; p += 10) {
                ctx.fillText(p.toString(), xScale(p), margin.top + height + 15);
                
                // Linhas de grade
                ctx.beginPath();
                ctx.strokeStyle = '#ccc';
                ctx.setLineDash([2, 2]);
                ctx.moveTo(xScale(p), margin.top);
                ctx.lineTo(xScale(p), margin.top + height);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Adicionar informa√ß√µes sobre par√¢metros
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Coes√£o: ${cohesion} MPa, √Çngulo de atrito: ${frictionAngle}¬∞, Raz√£o œÉ1/œÉ3: ${stressRatio.toFixed(1)}`, 
                         margin.left, margin.top + height + 40);
            
            ctx.font = 'italic 12px Arial';
            ctx.fillText('Efeito poroel√°stico inclu√≠do: ' + (poroFactor*100).toFixed(1) + '% da varia√ß√£o de press√£o transferida', 
                         margin.left, margin.top + height + 60);
        }
        
        // Fun√ß√£o para atualizar mapa de falha por cisalhamento
        function updateShearMap() {
            const ctx = shearFailureMap;
            const canvas = ctx.canvas;
            
            // Limpar canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Obter tipo de visualiza√ß√£o
            const mapType = document.getElementById('shear-map-type').value;
            
            // Obter valores dos controles
            const cohesion = parseFloat(document.getElementById('cohesion-slider').value);
            const frictionAngle = parseInt(document.getElementById('friction-angle-slider').value);
            const frictionRad = frictionAngle * Math.PI / 180;
            const stressRatio = parseFloat(document.getElementById('stress-ratio-slider').value);
            
            // Desenhar um mapa 2D colorido simulado
            const width = canvas.width;
            const height = canvas.height;
            
            // Simular dados
            const gridSize = 20;
            const cellWidth = width / gridSize;
            const cellHeight = height / gridSize;
            
            // Configura√ß√£o de poroelasticidade
            const biot = 0.8;
            const poisson = 0.25;
            const poroFactor = (biot/3) * (1 + poisson)/(1 - poisson);
            
            // Gerar dados de tens√£o e fator de seguran√ßa
            let dataField = [];
            let maxValue = 0;
            let minValue = Infinity;
            
            for (let y = 0; y < gridSize; y++) {
                dataField[y] = [];
                for (let x = 0; x < gridSize; x++) {
                    // Valores base para tens√£o vertical e horizontal
                    const baseSv = 30 + 10 * Math.sin(x/8) * Math.cos(y/7);
                    const baseShmin = baseSv / stressRatio;
                    
                    // Press√£o de poros inicial
                    const basePp = baseSv * 0.45;
                    
                    // Adicionar pluma de inje√ß√£o
                    const injectX = gridSize * 0.3;
                    const injectY = gridSize * 0.5;
                    const dx = x - injectX;
                    const dy = y - injectY;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // Efeito da inje√ß√£o diminui com a dist√¢ncia
                    const maxRadius = gridSize * 0.6;
                    const injectionFactor = Math.max(0, 1 - distance / maxRadius);
                    const injectionP = 15 * injectionFactor;
                    
                    // Press√£o final
                    const pressure = basePp + injectionP;
                    
                    // Efeito poroel√°stico na tens√£o
                    const dSv = poroFactor * injectionP;
                    const dShmin = poroFactor * injectionP;
                    
                    // Tens√µes efetivas
                    const svEff = baseSv + dSv - biot * pressure;
                    const shminEff = baseShmin + dShmin - biot * pressure;
                    
                    // Tens√£o diferencial
                    const diffStress = Math.abs(svEff - shminEff);
                    
                    // Tens√£o cisalhante (crit√©rio Mohr-Coulomb)
                    const shearStress = diffStress / 2;
                    
                    // Tens√£o normal m√©dia
                    const meanStress = (svEff + shminEff) / 2;
                    
                    // Resist√™ncia ao cisalhamento
                    const shearStrength = cohesion + meanStress * Math.sin(frictionRad);
                    
                    // Fator de seguran√ßa
                    const safetyFactor = shearStrength / shearStress;
                    
                    // Valor a ser exibido com base no tipo de mapa
                    let value;
                    
                    switch(mapType) {
                        case 'differential':
                            value = diffStress;
                            break;
                        case 'shear-strength':
                            value = shearStrength;
                            break;
                        case 'sf':
                            value = safetyFactor;
                            break;
                        default:
                            value = safetyFactor;
                    }
                    
                    dataField[y][x] = value;
                    maxValue = Math.max(maxValue, value);
                    minValue = Math.min(minValue, value);
                }
            }
            
            // Ajustar limites para fator de seguran√ßa
            if (mapType === 'sf') {
                minValue = Math.min(minValue, 0.8);
                maxValue = Math.max(maxValue, 1.5);
            }
            
            // Desenhar c√©lulas coloridas
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const value = dataField[y][x];
                    const normalizedValue = (value - minValue) / (maxValue - minValue);
                    
                    // Escolher cor com base no valor
                    let color;
                    
                    if (mapType === 'sf') {
                        // Escala espec√≠fica para fator de seguran√ßa
                        if (value < 1.0) {
                            // Vermelho para SF < 1.0 (falha)
                            color = '#ef4444';
                        } else if (value < 1.2) {
                            // Amarelo para 1.0 <= SF < 1.2 (aten√ß√£o)
                            color = '#f59e0b';
                        } else {
                            // Verde para SF >= 1.2 (seguro)
                            color = '#10b981';
                        }
                    } else if (mapType === 'differential') {
                        // Escala vermelho para tens√£o diferencial (vermelho = alta)
                        const intensity = Math.min(255, Math.round(255 * normalizedValue));
                        color = `rgb(${intensity}, ${255-intensity}, 0)`;
                    } else {
                        // Escala verde para resist√™ncia (verde = alta)
                        const intensity = Math.min(255, Math.round(255 * normalizedValue));
                        color = `rgb(0, ${intensity}, ${255-intensity})`;
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                    
                    // Adicionar contorno
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.strokeRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                    
                    // Adicionar valor para o fator de seguran√ßa em algumas c√©lulas
                    if (mapType === 'sf' && (x + y) % 6 === 0) {
                        ctx.fillStyle = 'white';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(value.toFixed(2), x * cellWidth + cellWidth/2, y * cellHeight + cellHeight/2 + 3);
                    }
                }
            }
            
            // Adicionar legenda de cores se n√£o for fator de seguran√ßa
            if (mapType !== 'sf') {
                const legendWidth = 30;
                const legendHeight = height * 0.8;
                const legendX = width - legendWidth - 20;
                const legendY = height * 0.1;
                
                if (mapType === 'differential') {
                    // Escala para tens√£o diferencial (gradiente amarelo-vermelho)
                    for (let i = 0; i < legendHeight; i++) {
                        const normalizedValue = 1 - i / legendHeight;
                        const intensity = Math.min(255, Math.round(255 * normalizedValue));
                        const color = `rgb(${intensity}, ${255-intensity}, 0)`;
                        
                        ctx.fillStyle = color;
                        ctx.fillRect(legendX, legendY + i, legendWidth, 1);
                    }
                } else {
                    // Escala para resist√™ncia (gradiente azul-verde)
                    for (let i = 0; i < legendHeight; i++) {
                        const normalizedValue = 1 - i / legendHeight;
                        const intensity = Math.min(255, Math.round(255 * normalizedValue));
                        const color = `rgb(0, ${intensity}, ${255-intensity})`;
                        
                        ctx.fillStyle = color;
                        ctx.fillRect(legendX, legendY + i, legendWidth, 1);
                    }
                }
                
                // Contorno da legenda
                ctx.strokeStyle = '#333';
                ctx.strokeRect(legendX, legendY, legendWidth, legendHeight);
                
                // Valores da legenda
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(maxValue.toFixed(1) + ' MPa', legendX - 5, legendY + 12);
                ctx.fillText(minValue.toFixed(1) + ' MPa', legendX - 5, legendY + legendHeight);
            }
            
            // T√≠tulo do mapa
            let title;
            switch(mapType) {
                case 'differential':
                    title = 'Tens√£o Diferencial (œÉ1-œÉ3)';
                    break;
                case 'shear-strength':
                    title = 'Resist√™ncia ao Cisalhamento (C + œÉ¬∑tanœÜ)';
                    break;
                case 'sf':
                    title = 'Fator de Seguran√ßa para Cisalhamento';
                    break;
                default:
                    title = 'An√°lise de Cisalhamento';
            }
            
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(title, width/2, 20);
            
            // Adicionar po√ßo injetor
            ctx.lineWidth = 3;
            ctx.setLineDash([]);
            
            // Po√ßo injetor
            ctx.strokeStyle = '#1E88E5';
            ctx.beginPath();
            ctx.arc(width * 0.3, height * 0.5, 10, 0, Math.PI * 2);
            ctx.stroke();
            
            // Adicionar r√≥tulo
            ctx.font = '12px Arial';
            ctx.fillStyle = '#1565C0';
            ctx.textAlign = 'center';
            ctx.fillText('Injetor', width * 0.3, height * 0.5 - 15);
            
            // Adicionar informa√ß√£o sobre par√¢metros
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`C = ${cohesion} MPa, œÜ = ${frictionAngle}¬∞, Raz√£o œÉ1/œÉ3 = ${stressRatio.toFixed(1)}`, 20, height - 10);
        }
        
        // Fun√ß√£o para atualizar C√≠rculo de Mohr
        function updateMohrCircle() {
            const ctx = mohrCircleCanvas;
            const canvas = ctx.canvas;
            
            // Limpar canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Obter valores dos controles
            const sigma1 = parseFloat(document.getElementById('sigma1-slider').value);
            document.getElementById('sigma1-value').textContent = sigma1 + ' MPa';
            
            const sigma3 = parseFloat(document.getElementById('sigma3-slider').value);
            document.getElementById('sigma3-value').textContent = sigma3 + ' MPa';
            
            const pp = parseFloat(document.getElementById('pp-slider').value);
            document.getElementById('pp-value').textContent = pp + ' MPa';
            
            const cohesion = parseFloat(document.getElementById('mohr-cohesion-slider').value);
            document.getElementById('mohr-cohesion-value').textContent = cohesion + ' MPa';
            
            const friction = parseInt(document.getElementById('mohr-friction-slider').value);
            document.getElementById('mohr-friction-value').textContent = friction + '¬∞';
            
            const usePoroelastic = document.getElementById('mohr-poroelastic-toggle').checked;
            
            // Configura√ß√£o de poroelasticidade
            const biot = 0.8;
            const poisson = 0.25;
            const poroFactor = (biot/3) * (1 + poisson)/(1 - poisson);
            
            // Definir margens e calculando escala
            const margin = {top: 50, right: 40, bottom: 60, left: 60};
            const width = canvas.width - margin.left - margin.right;
            const height = canvas.height - margin.top - margin.bottom;
            
            // Configurar escala
            const maxSigma = 80; // MPa
            const maxTau = 40; // MPa
            
            // Centro do gr√°fico
            const centerX = margin.left + width / 2;
            const centerY = margin.top + height / 2;
            
            // Fun√ß√£o para converter valores para coordenadas
            function xScale(sigma) {
                return centerX + (sigma / maxSigma) * width / 2;
            }
            
            function yScale(tau) {
                return centerY - (tau / maxTau) * height / 2;
            }
            
            // Desenhar t√≠tulo
            ctx.fillStyle = '#333';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('C√≠rculo de Mohr e Envelope de Falha', canvas.width/2, 20);
            
            // Desenhar eixos
            ctx.beginPath();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.moveTo(margin.left, centerY);
            ctx.lineTo(margin.left + width, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX, margin.top);
            ctx.lineTo(centerX, margin.top + height);
            ctx.stroke();
            
            // R√≥tulos dos eixos
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Tens√£o Normal (œÉ)', centerX, margin.top + height + 30);
            
            ctx.save();
            ctx.translate(margin.left - 30, centerY);
            ctx.rotate(-Math.PI/2);
            ctx.textAlign = 'center';
            ctx.fillText('Tens√£o de Cisalhamento (œÑ)', 0, 0);
            ctx.restore();
            
            // Desenhar marca√ß√µes nos eixos
            ctx.textAlign = 'center';
            ctx.font = '10px Arial';
            
            for (let s = -maxSigma/2; s <= maxSigma/2; s += 10) {
                const xPos = xScale(s);
                ctx.fillText(s.toString(), xPos, centerY + 15);
                
                // Linhas de grade
                ctx.beginPath();
                ctx.strokeStyle = '#ccc';
                ctx.setLineDash([2, 2]);
                ctx.moveTo(xPos, margin.top);
                ctx.lineTo(xPos, margin.top + height);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            for (let t = -maxTau/2; t <= maxTau/2; t += 10) {
                if (t === 0) continue; // Pular o zero (eixo x)
                
                const yPos = yScale(t);
                ctx.fillText(Math.abs(t).toString(), centerX - 20, yPos + 4);
                
                // Linhas de grade
                ctx.beginPath();
                ctx.strokeStyle = '#ccc';
                ctx.setLineDash([2, 2]);
                ctx.moveTo(margin.left, yPos);
                ctx.lineTo(margin.left + width, yPos);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Calcular tens√µes efetivas e c√≠rculos de Mohr
            // Efeito poroel√°stico (se ativado)
            let dSigma1 = 0;
            let dSigma3 = 0;
            
            if (usePoroelastic) {
                // Estimando press√£o inicial como 10 MPa
                const initialPp = 10;
                const deltaPp = pp - initialPp;
                
                // Efeito poroel√°stico na tens√£o
                dSigma1 = poroFactor * Math.max(0, deltaPp);
                dSigma3 = poroFactor * Math.max(0, deltaPp);
            }
            
            // Tens√µes totais
            const sigma1Total = sigma1 + dSigma1;
            const sigma3Total = sigma3 + dSigma3;
            
            // Tens√µes efetivas
            const sigma1Eff = sigma1Total - biot * pp;
            const sigma3Eff = sigma3Total - biot * pp;
            
            // Par√¢metros do c√≠rculo
            const centerSigma = (sigma1Eff + sigma3Eff) / 2;
            const radius = (sigma1Eff - sigma3Eff) / 2;
            
            // Desenhar c√≠rculo de Mohr
            ctx.beginPath();
            ctx.strokeStyle = '#1f77b4';
            ctx.lineWidth = 3;
            ctx.arc(
                xScale(centerSigma),
                centerY,
                radius * width / 2 / maxSigma,
                0,
                Math.PI * 2
            );
            ctx.stroke();
            
            // Desenhar envelope de falha Mohr-Coulomb
            const frictionRad = friction * Math.PI / 180;
            
            ctx.beginPath();
            ctx.strokeStyle = '#d62728';
            ctx.lineWidth = 2;
            
            // Linha de falha (œÑ = c + œÉ*tan(œÜ))
            const xMin = -maxSigma/2;
            const xMax = maxSigma/2;
            
            ctx.moveTo(xScale(xMin), yScale(-(cohesion + xMin * Math.tan(frictionRad))));
            ctx.lineTo(xScale(xMax), yScale(-(cohesion + xMax * Math.tan(frictionRad))));
            ctx.stroke();
            
            // Sombrear √°rea segura
            ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
            ctx.beginPath();
            
            // Linha superior
            ctx.moveTo(xScale(xMin), yScale(cohesion + xMin * Math.tan(frictionRad)));
            ctx.lineTo(xScale(xMax), yScale(cohesion + xMax * Math.tan(frictionRad)));
            
            // Arco at√© o lado direito
            ctx.lineTo(xScale(xMax), centerY);
            
            // Eixo x at√© a origem
            ctx.lineTo(xScale(xMin), centerY);
            
            // Voltar ao in√≠cio
            ctx.closePath();
            ctx.fill();
            
            // Sombrear √°rea segura inferior
            ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
            ctx.beginPath();
            
            // Linha inferior
            ctx.moveTo(xScale(xMin), yScale(-(cohesion + xMin * Math.tan(frictionRad))));
            ctx.lineTo(xScale(xMax), yScale(-(cohesion + xMax * Math.tan(frictionRad))));
            
            // Arco at√© o lado direito
            ctx.lineTo(xScale(xMax), centerY);
            
            // Eixo x at√© a origem
            ctx.lineTo(xScale(xMin), centerY);
            
            // Voltar ao in√≠cio
            ctx.closePath();
            ctx.fill();
            
            // Marcar pontos do c√≠rculo para œÉ1 e œÉ3
            ctx.fillStyle = '#1f77b4';
            
            // Ponto para œÉ3
            ctx.beginPath();
            ctx.arc(xScale(sigma3Eff), centerY, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // Ponto para œÉ1
            ctx.beginPath();
            ctx.arc(xScale(sigma1Eff), centerY, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // Adicionar r√≥tulos
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            
            ctx.fillText('œÉ3\'', xScale(sigma3Eff), centerY + 20);
            ctx.fillText('œÉ1\'', xScale(sigma1Eff), centerY + 20);
            
            // Adicionar linha para o ponto cr√≠tico (c√≠rculo tocando envelope)
            // Calcular o ponto de interse√ß√£o
            const alpha = Math.atan(Math.sin(frictionRad) / (1 - Math.cos(frictionRad)));
            const rCrit = radius * Math.cos(alpha);
            const sigmaCrit = centerSigma + radius * Math.cos(alpha + Math.PI);
            const tauCrit = radius * Math.sin(alpha + Math.PI);
            
            // Desenhar linha at√© o ponto cr√≠tico
            ctx.beginPath();
            ctx.strokeStyle = '#ff7f0e';
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            
            ctx.moveTo(xScale(centerSigma), centerY);
            ctx.lineTo(xScale(sigmaCrit), yScale(tauCrit));
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Marcar ponto cr√≠tico
            ctx.fillStyle = '#ff7f0e';
            ctx.beginPath();
            ctx.arc(xScale(sigmaCrit), yScale(tauCrit), 6, 0, Math.PI * 2);
            ctx.fill();
            
            // Calcular e mostrar fator de seguran√ßa
            const fricSF = (cohesion + centerSigma * Math.sin(frictionRad)) / radius;
            
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            
            let sfColor;
            if (fricSF < 1.0) {
                sfColor = '#ef4444'; // Vermelho
            } else if (fricSF < 1.2) {
                sfColor = '#f59e0b'; // Amarelo
            } else {
                sfColor = '#10b981'; // Verde
            }
            
            ctx.fillStyle = sfColor;
            ctx.fillText(`Fator de Seguran√ßa: ${fricSF.toFixed(2)}`, margin.left, margin.top - 10);
            
            // Adicionar nota sobre efeito poroel√°stico
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            
            if (usePoroelastic) {
                ctx.fillText(`Efeito poroel√°stico ativado: ŒîœÉ = ${dSigma1.toFixed(2)} MPa`, 
                            margin.left + width, margin.top - 10);
            } else {
                ctx.fillText('Efeito poroel√°stico desativado', margin.left + width, margin.top - 10);
            }
            
            // Adicionar legenda principal
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            
            const legendItems = [
                { text: 'C√≠rculo de Mohr', color: '#1f77b4' },
                { text: 'Envelope de Falha Mohr-Coulomb', color: '#d62728' },
                { text: 'Ponto Cr√≠tico', color: '#ff7f0e' }
            ];
            
            legendItems.forEach((item, i) => {
                const legendY = margin.top + 20 + i * 20;
                
                // Texto
                ctx.fillStyle = '#333';
                ctx.fillText(item.text, margin.left + 30, legendY);
                
                // S√≠mbolo
                ctx.fillStyle = item.color;
                ctx.beginPath();
                ctx.arc(margin.left + 15, legendY - 4, 6, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Par√¢metros do c√≠rculo
            ctx.fillStyle = '#333';
            ctx.textAlign = 'left';
            ctx.font = '12px Arial';
            
            ctx.fillText(`œÉ1 = ${sigma1.toFixed(1)} MPa`, margin.left + 20, margin.top + height - 40);
            ctx.fillText(`œÉ3 = ${sigma3.toFixed(1)} MPa`, margin.left + 20, margin.top + height - 20);
            ctx.fillText(`Pp = ${pp.toFixed(1)} MPa`, margin.left + 150, margin.top + height - 40);
            ctx.fillText(`c = ${cohesion.toFixed(1)} MPa, œÜ = ${friction}¬∞`, margin.left + 150, margin.top + height - 20);
        }
        
        // Fun√ß√£o para animar o c√≠rculo de Mohr com aumento de press√£o
        function animateMohrCircle() {
            const startPp = parseFloat(document.getElementById('pp-slider').value);
            const maxPp = 30;
            const duration = 3000; // ms
            const step = 0.5;
            
            let currentPp = startPp;
            const startTime = Date.now();
            
            const animate = function() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(1, elapsed / duration);
                
                currentPp = startPp + progress * (maxPp - startPp);
                
                document.getElementById('pp-slider').value = currentPp;
                document.getElementById('pp-value').textContent = currentPp.toFixed(1) + ' MPa';
                
                updateMohrCircle();
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            };
            
            animate();
        }
        
        // Fun√ß√£o para atualizar visualiza√ß√£o de fatores de seguran√ßa
        function updateSafetyFactorView() {
            const ctx = safetyFactorCanvas;
            const canvas = ctx.canvas;
            
            // Limpar canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Obter valores dos controles
            const viewPlane = document.getElementById('view-plane').value;
            const slicePosition = parseInt(document.getElementById('slice-position-slider').value);
            document.getElementById('slice-position-value').textContent = slicePosition + '%';
            
            const viewMode = document.getElementById('safety-view-mode').value;
            
            // Configurar dimens√µes
            const width = canvas.width;
            const height = canvas.height;
            const margin = {top: 30, right: 20, bottom: 50, left: 60};
            
            // Definir t√≠tulo
            let title;
            switch(viewMode) {
                case 'hydraulic':
                    title = 'Fator de Seguran√ßa para Fraturamento Hidr√°ulico';
                    break;
                case 'shear':
                    title = 'Fator de Seguran√ßa para Cisalhamento';
                    break;
                case 'minimum':
                    title = 'Fator de Seguran√ßa M√≠nimo (Hidr√°ulico vs. Cisalhamento)';
                    break;
                case 'risk':
                    title = 'Zonas de Risco';
                    break;
                default:
                    title = 'An√°lise de Seguran√ßa';
            }
            
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(title, width/2, margin.top - 10);
            
            // Determinar o corte 3D com base na visualiza√ß√£o e posi√ß√£o
            let slice = {};
            const {x, y, z} = simulatedData.dimensions;
            
            switch(viewPlane) {
                case 'horizontal':
                    slice.dim1 = x;
                    slice.dim2 = y;
                    slice.pos = Math.floor(z * slicePosition / 100);
                    slice.label1 = 'X';
                    slice.label2 = 'Y';
                    break;
                case 'vertical-x':
                    slice.dim1 = x;
                    slice.dim2 = z;
                    slice.pos = Math.floor(y * slicePosition / 100);
                    slice.label1 = 'X';
                    slice.label2 = 'Z';
                    break;
                case 'vertical-y':
                    slice.dim1 = y;
                    slice.dim2 = z;
                    slice.pos = Math.floor(x * slicePosition / 100);
                    slice.label1 = 'Y';
                    slice.label2 = 'Z';
                    break;
                default:
                    slice.dim1 = x;
                    slice.dim2 = y;
                    slice.pos = Math.floor(z * slicePosition / 100);
                    slice.label1 = 'X';
                    slice.label2 = 'Y';
            }
            
            // Calcular dimens√µes da visualiza√ß√£o
            const visWidth = width - margin.left - margin.right;
            const visHeight = height - margin.top - margin.bottom;
            
            const cellWidth = visWidth / slice.dim1;
            const cellHeight = visHeight / slice.dim2;
            
            // Fun√ß√£o para obter valor de fator de seguran√ßa no ponto
            function getSafetyFactor(i, j) {
                let tensoralSF, shearSF;
                
                if (viewPlane === 'horizontal') {
                    tensoralSF = simulatedData.safetyFactors.tensile[slice.pos][j][i];
                    shearSF = simulatedData.safetyFactors.shear[slice.pos][j][i];
                } else if (viewPlane === 'vertical-x') {
                    tensoralSF = simulatedData.safetyFactors.tensile[j][slice.pos][i];
                    shearSF = simulatedData.safetyFactors.shear[j][slice.pos][i];
                } else { // vertical-y
                    tensoralSF = simulatedData.safetyFactors.tensile[j][i][slice.pos];
                    shearSF = simulatedData.safetyFactors.shear[j][i][slice.pos];
                }
                
                switch(viewMode) {
                    case 'hydraulic':
                        return tensoralSF;
                    case 'shear':
                        return shearSF;
                    case 'minimum':
                        return Math.min(tensoralSF, shearSF);
                    case 'risk':
                        return Math.min(tensoralSF, shearSF);
                    default:
                        return Math.min(tensoralSF, shearSF);
                }
            }
            
            // Desenhar a visualiza√ß√£o
            for (let i = 0; i < slice.dim1; i++) {
                for (let j = 0; j < slice.dim2; j++) {
                    const sf = getSafetyFactor(i, j);
                    
                    let color;
                    if (viewMode === 'risk') {
                        // Visualiza√ß√£o especial para zonas de risco
                        if (sf < 1.0) {
                            color = '#ef4444'; // Vermelho (falha)
                        } else if (sf < 1.2) {
                            color = '#f59e0b'; // Amarelo (aten√ß√£o)
                        } else {
                            color = '#10b981'; // Verde (seguro)
                        }
                    } else {
                        // Usar escala de cores cont√≠nua
                        if (sf < 1.0) {
                            // Vermelho para valores cr√≠ticos
                            const intensity = Math.max(0, sf) / 1.0;
                            color = `rgb(255, ${Math.round(intensity * 100)}, ${Math.round(intensity * 100)})`;
                        } else if (sf < 1.5) {
                            // Amarelo para valores intermedi√°rios
                            const intensity = (sf - 1.0) / 0.5;
                            color = `rgb(${Math.round(255 - intensity * 100)}, 255, 0)`;
                        } else {
                            // Verde para valores seguros
                            const intensity = Math.min(1, (sf - 1.5) / 1.5);
                            color = `rgb(0, 255, ${Math.round(100 + intensity * 155)})`;
                        }
                    }
                    
                    // Desenhar c√©lula
                    ctx.fillStyle = color;
                    ctx.fillRect(
                        margin.left + i * cellWidth, 
                        margin.top + j * cellHeight, 
                        cellWidth, 
                        cellHeight
                    );
                    
                    // Adicionar borda
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.strokeRect(
                        margin.left + i * cellWidth, 
                        margin.top + j * cellHeight, 
                        cellWidth, 
                        cellHeight
                    );
                    
                    // Adicionar valor em algumas c√©lulas
                    if ((i + j) % 10 === 0 && cellWidth > 15) {
                        ctx.fillStyle = sf < 1.2 ? 'white' : 'black';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(
                            sf.toFixed(2), 
                            margin.left + i * cellWidth + cellWidth/2, 
                            margin.top + j * cellHeight + cellHeight/2 + 3
                        );
                    }
                }
            }
            
            // Adicionar eixos e r√≥tulos
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            
            // Eixo horizontal
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top + visHeight);
            ctx.lineTo(margin.left + visWidth, margin.top + visHeight);
            ctx.stroke();
            
            // Eixo vertical
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, margin.top + visHeight);
            ctx.stroke();
            
            // R√≥tulos dos eixos
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Dire√ß√£o ${slice.label1}`, margin.left + visWidth/2, margin.top + visHeight + 35);
            
            ctx.save();
            ctx.translate(margin.left - 35, margin.top + visHeight/2);
            ctx.rotate(-Math.PI/2);
            ctx.textAlign = 'center';
            ctx.fillText(`Dire√ß√£o ${slice.label2}`, 0, 0);
            ctx.restore();
            
            // Informa√ß√£o sobre o corte
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            
            let cutInfo;
            switch(viewPlane) {
                case 'horizontal':
                    cutInfo = `Corte horizontal Z=${slice.pos} (${slicePosition}%)`;
                    break;
                case 'vertical-x':
                    cutInfo = `Corte vertical Y=${slice.pos} (${slicePosition}%)`;
                    break;
                case 'vertical-y':
                    cutInfo = `Corte vertical X=${slice.pos} (${slicePosition}%)`;
                    break;
            }
            
            ctx.fillText(cutInfo, margin.left, height - 10);
            
            // Adicionar legenda
            const legendX = margin.left + visWidth - 100;
            const legendY = margin.top + 20;
            
            ctx.fillStyle = '#333';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Legenda:', legendX, legendY);
            
            const legendItems = [
                { label: 'SF < 1.0 (Falha)', color: '#ef4444' },
                { label: '1.0 ‚â§ SF < 1.2 (Aten√ß√£o)', color: '#f59e0b' },
                { label: 'SF ‚â• 1.2 (Seguro)', color: '#10b981' }
            ];
            
            legendItems.forEach((item, i) => {
                const itemY = legendY + 20 + i * 20;
                
                // Ret√¢ngulo colorido
                ctx.fillStyle = item.color;
                ctx.fillRect(legendX, itemY - 10, 12, 12);
                
                // Texto
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(item.label, legendX + 18, itemY);
            });
            
            // Adicionar informa√ß√£o sobre po√ßos se for vista horizontal
            if (viewPlane === 'horizontal') {
                // Po√ßo injetor
                ctx.strokeStyle = '#1E88E5';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(
                    margin.left + visWidth * 0.3, 
                    margin.top + visHeight * 0.5, 
                    8, 0, Math.PI * 2
                );
                ctx.stroke();
                
                // Po√ßo produtor
                ctx.strokeStyle = '#E53935';
                ctx.beginPath();
                ctx.arc(
                    margin.left + visWidth * 0.7, 
                    margin.top + visHeight * 0.5, 
                    8, 0, Math.PI * 2
                );
                ctx.stroke();
                
                // R√≥tulos
                ctx.font = '12px Arial';
                ctx.fillStyle = '#1565C0';
                ctx.textAlign = 'center';
                ctx.fillText('Injetor', margin.left + visWidth * 0.3, margin.top + visHeight * 0.5 - 15);
                
                ctx.fillStyle = '#C62828';
                ctx.fillText('Produtor', margin.left + visWidth * 0.7, margin.top + visHeight * 0.5 - 15);
            }
        }
        
        // Fun√ß√£o para atualizar gr√°ficos do fluxo de trabalho
        function updateWorkflowGraphics() {
            // Desenhar gr√°ficos simplificados para cada etapa do workflow
            
            // Etapa 1: Caracteriza√ß√£o do Estado de Tens√µes Inicial
            const ctx1 = workflowCanvases[0];
            ctx1.clearRect(0, 0, ctx1.canvas.width, ctx1.canvas.height);
            
            // Desenhar gradientes de tens√£o simplificados
            const width = ctx1.canvas.width;
            const height = ctx1.canvas.height;
            
            ctx1.strokeStyle = '#1f77b4';
            ctx1.lineWidth = 2;
            ctx1.beginPath();
            ctx1.moveTo(20, 20);
            ctx1.lineTo(width - 20, height - 20);
            ctx1.stroke();
            
            ctx1.strokeStyle = '#ff7f0e';
            ctx1.beginPath();
            ctx1.moveTo(20, 30);
            ctx1.lineTo(width - 20, height - 40);
            ctx1.stroke();
            
            ctx1.strokeStyle = '#2ca02c';
            ctx1.beginPath();
            ctx1.moveTo(20, 40);
            ctx1.lineTo(width - 20, height - 60);
            ctx1.stroke();
            
            ctx1.fillStyle = '#333';
            ctx1.font = '10px Arial';
            ctx1.textAlign = 'center';
            ctx1.fillText('Gradientes de Tens√£o', width/2, 15);
            
            // Etapa 2: Propriedades Mec√¢nicas
            const ctx2 = workflowCanvases[1];
            ctx2.clearRect(0, 0, ctx2.canvas.width, ctx2.canvas.height);
            
            // Desenhar representa√ß√£o de propriedades da rocha
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 3;
            
            // Desenhar c√≠rculo representando a rocha
            ctx2.fillStyle = '#f8f9fa';
            ctx2.beginPath();
            ctx2.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx2.fill();
            
            ctx2.strokeStyle = '#777';
            ctx2.lineWidth = 1;
            ctx2.beginPath();
            ctx2.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx2.stroke();
            
            // Adicionar "poros"
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * radius * 0.8;
                const porSize = 2 + Math.random() * 4;
                
                const x = centerX + Math.cos(angle) * distance;
                const y = centerY + Math.sin(angle) * distance;
                
                ctx2.fillStyle = '#ddd';
                ctx2.beginPath();
                ctx2.arc(x, y, porSize, 0, Math.PI * 2);
                ctx2.fill();
            }
            
            // Adicionar s√≠mbolos de propriedades
            ctx2.fillStyle = '#333';
            ctx2.font = '12px Arial';
            
            ctx2.textAlign = 'center';
            ctx2.fillText('E', centerX - radius/2, centerY - radius/2);
            ctx2.fillText('ŒΩ', centerX + radius/2, centerY - radius/2);
            ctx2.fillText('C', centerX - radius/2, centerY + radius/2);
            ctx2.fillText('œÜ', centerX + radius/2, centerY + radius/2);
            
            ctx2.fillStyle = '#333';
            ctx2.font = '10px Arial';
            ctx2.textAlign = 'center';
            ctx2.fillText('Propriedades Mec√¢nicas', width/2, 15);
            
            // Etapa 3: Efeitos Poroel√°sticos
            const ctx3 = workflowCanvases[2];
            ctx3.clearRect(0, 0, ctx3.canvas.width, ctx3.canvas.height);
            
            // Desenhar representa√ß√£o de efeito poroel√°stico
            // C√≠rculo inicial
            ctx3.strokeStyle = '#1f77b4';
            ctx3.lineWidth = 2;
            ctx3.beginPath();
            ctx3.arc(width/2 - 30, height/2, 30, 0, Math.PI * 2);
            ctx3.stroke();
            
            // Seta indicando expans√£o
            ctx3.strokeStyle = '#ff7f0e';
            ctx3.lineWidth = 1.5;
            ctx3.beginPath();
            
            // Topo
            ctx3.moveTo(width/2 - 30, height/2 - 30);
            ctx3.lineTo(width/2 - 30, height/2 - 40);
            ctx3.moveTo(width/2 - 34, height/2 - 36);
            ctx3.lineTo(width/2 - 30, height/2 - 40);
            ctx3.lineTo(width/2 - 26, height/2 - 36);
            
            // Direita
            ctx3.moveTo(width/2, height/2);
            ctx3.lineTo(width/2 + 10, height/2);
            ctx3.moveTo(width/2 + 6, height/2 - 4);
            ctx3.lineTo(width/2 + 10, height/2);
            ctx3.lineTo(width/2 + 6, height/2 + 4);
            
            // Esquerda
            ctx3.moveTo(width/2 - 60, height/2);
            ctx3.lineTo(width/2 - 70, height/2);
            ctx3.moveTo(width/2 - 66, height/2 - 4);
            ctx3.lineTo(width/2 - 70, height/2);
            ctx3.lineTo(width/2 - 66, height/2 + 4);
            
            // Baixo
            ctx3.moveTo(width/2 - 30, height/2 + 30);
            ctx3.lineTo(width/2 - 30, height/2 + 40);
            ctx3.moveTo(width/2 - 34, height/2 + 36);
            ctx3.lineTo(width/2 - 30, height/2 + 40);
            ctx3.lineTo(width/2 - 26, height/2 + 36);
            
            ctx3.stroke();
            
            // C√≠rculo expandido
            ctx3.strokeStyle = '#2ca02c';
            ctx3.setLineDash([3, 3]);
            ctx3.beginPath();
            ctx3.arc(width/2 - 30, height/2, 40, 0, Math.PI * 2);
            ctx3.stroke();
            ctx3.setLineDash([]);
            
            // S√≠mbolo de press√£o no centro
            ctx3.fillStyle = '#d62728';
            ctx3.font = '14px Arial';
            ctx3.textAlign = 'center';
            ctx3.fillText('P', width/2 - 30, height/2 + 4);
            
            ctx3.fillStyle = '#333';
            ctx3.font = '10px Arial';
            ctx3.fillText('Efeito Poroel√°stico', width/2, 15);
            
            // Etapa 4: Simula√ß√£o de Press√£o
            const ctx4 = workflowCanvases[3];
            ctx4.clearRect(0, 0, ctx4.canvas.width, ctx4.canvas.height);
            
            // Desenhar grade de simula√ß√£o
            const gridSize = 10;
            const cellSize = Math.min(width, height) / gridSize;
            
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    // Calcular cor baseada em uma "press√£o" simulada
                    const centerI = gridSize / 2;
                    const centerJ = gridSize / 2;
                    
                    const dist = Math.sqrt(Math.pow(i - centerI, 2) + Math.pow(j - centerJ, 2));
                    const maxDist = Math.sqrt(Math.pow(gridSize, 2));
                    
                    const pressure = 1 - Math.min(1, dist / (maxDist/2));
                    
                    let color;
                    if (pressure < 0.3) {
                        color = '#b3e5fc'; // Azul claro
                    } else if (pressure < 0.6) {
                        color = '#29b6f6'; // Azul m√©dio
                    } else if (pressure < 0.8) {
                        color = '#0288d1'; // Azul escuro
                    } else {
                        color = '#01579b'; // Azul muito escuro
                    }
                    
                    ctx4.fillStyle = color;
                    ctx4.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                    
                    ctx4.strokeStyle = 'rgba(255,255,255,0.3)';
                    ctx4.strokeRect(i * cellSize, j * cellSize, cellSize, cellSize);
                }
            }
            
            // Po√ßo injetor
            ctx4.fillStyle = '#e53935';
            ctx4.beginPath();
            ctx4.arc(width/2, height/2, 5, 0, Math.PI * 2);
            ctx4.fill();
            
            ctx4.fillStyle = '#333';
            ctx4.font = '10px Arial';
            ctx4.textAlign = 'center';
            ctx4.fillText('Simula√ß√£o de Press√£o', width/2, 15);
            
            // Etapa 5: Fatores de Seguran√ßa
            const ctx5 = workflowCanvases[4];
            ctx5.clearRect(0, 0, ctx5.canvas.width, ctx5.canvas.height);
            
            // Desenhar mapa de fator de seguran√ßa
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    // Calcular SF baseado em posi√ß√£o
                    const centerI = gridSize / 2;
                    const centerJ = gridSize / 2;
                    
                    const dist = Math.sqrt(Math.pow(i - centerI, 2) + Math.pow(j - centerJ, 2));
                    const maxDist = Math.sqrt(Math.pow(gridSize, 2));
                    
                    // SF diminui pr√≥ximo ao po√ßo
                    const sf = 0.8 + 1.5 * (dist / (maxDist/1.5));
                    
                    let color;
                    if (sf < 1.0) {
                        color = '#ef4444'; // Vermelho
                    } else if (sf < 1.2) {
                        color = '#f59e0b'; // Amarelo
                    } else {
                        color = '#10b981'; // Verde
                    }
                    
                    ctx5.fillStyle = color;
                    ctx5.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                    
                    ctx5.strokeStyle = 'rgba(0,0,0,0.1)';
                    ctx5.strokeRect(i * cellSize, j * cellSize, cellSize, cellSize);
                }
            }
            
            // Po√ßo injetor
            ctx5.fillStyle = '#e53935';
            ctx5.beginPath();
            ctx5.arc(width/2, height/2, 5, 0, Math.PI * 2);
            ctx5.fill();
            
            ctx5.fillStyle = '#333';
            ctx5.font = '10px Arial';
            ctx5.textAlign = 'center';
            ctx5.fillText('Fatores de Seguran√ßa', width/2, 15);
            
            // Etapa 6: Visualiza√ß√£o e An√°lise
            const ctx6 = workflowCanvases[5];
            ctx6.clearRect(0, 0, ctx6.canvas.width, ctx6.canvas.height);
            
            // Desenhar gr√°fico de barras para SF
            const barWidth = 20;
            const maxHeight = height - 40;
            
            const bars = [
                { label: 'A', sf: 1.8, color: '#10b981' },
                { label: 'B', sf: 1.3, color: '#10b981' },
                { label: 'C', sf: 1.1, color: '#f59e0b' },
                { label: 'D', sf: 0.9, color: '#ef4444' },
                { label: 'E', sf: 1.4, color: '#10b981' }
            ];
            
            const spacing = (width - bars.length * barWidth) / (bars.length + 1);
            
            // Desenhar eixo Y
            ctx6.strokeStyle = '#333';
            ctx6.beginPath();
            ctx6.moveTo(spacing, 25);
            ctx6.lineTo(spacing, height - 15);
            ctx6.stroke();
            
            // Linha de SF = 1.0
            ctx6.strokeStyle = '#d62728';
            ctx6.setLineDash([2, 2]);
            
            const sfOneY = height - 15 - (1.0 / 2.0) * maxHeight;
            ctx6.beginPath();
            ctx6.moveTo(spacing, sfOneY);
            ctx6.lineTo(width - spacing, sfOneY);
            ctx6.stroke();
            
            ctx6.fillStyle = '#d62728';
            ctx6.font = '10px Arial';
            ctx6.textAlign = 'right';
            ctx6.fillText('SF = 1.0', spacing - 5, sfOneY + 4);
            
            ctx6.setLineDash([]);
            
            // Desenhar barras
            bars.forEach((bar, i) => {
                const x = spacing * (i + 1) + barWidth * i;
                const barHeight = (bar.sf / 2.0) * maxHeight;
                const y = height - 15 - barHeight;
                
                ctx6.fillStyle = bar.color;
                ctx6.fillRect(x, y, barWidth, barHeight);
                
                ctx6.strokeStyle = '#333';
                ctx6.strokeRect(x, y, barWidth, barHeight);
                
                // Valor de SF
                ctx6.fillStyle = '#333';
                ctx6.font = '10px Arial';
                ctx6.textAlign = 'center';
                ctx6.fillText(bar.sf.toFixed(1), x + barWidth/2, y - 5);
                
                // R√≥tulo
                ctx6.fillText(bar.label, x + barWidth/2, height - 5);
            });
            
            ctx6.fillStyle = '#333';
            ctx6.font = '10px Arial';
            ctx6.textAlign = 'center';
            ctx6.fillText('Visualiza√ß√£o e An√°lise', width/2, 15);
        }
        
        // Fun√ß√£o para atualizar visualiza√ß√£o de workflow em Petrel
        function updatePetrelWorkflow() {
            const ctx = petrelWorkflowCanvas;
            const canvas = ctx.canvas;
            
            // Limpar canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Obter tipo de visualiza√ß√£o
            const workflowStep = document.getElementById('petrel-workflow-step').value;
            
            // Configurar dimens√µes
            const width = canvas.width;
            const height = canvas.height;
            
            // Desenhar t√≠tulo
            let title;
            switch(workflowStep) {
                case 'model':
                    title = 'Modelo Geol√≥gico 3D';
                    break;
                case 'properties':
                    title = 'Propriedades Geomec√¢nicas';
                    break;
                case 'pressure':
                    title = 'Campo de Press√µes';
                    break;
                case 'safety':
                    title = 'Fatores de Seguran√ßa';
                    break;
                default:
                    title = 'Workflow em Petrel';
            }
            
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(title, width/2, 20);
            
            // Desenhar visualiza√ß√£o 3D simulada
            ctx.save();
            ctx.translate(width/2, height/2);
            
            // Modelo 3D isom√©trico simplificado
            const boxWidth = 200;
            const boxHeight = 120;
            const boxDepth = 150;
            
            // √Çngulos para proje√ß√£o isom√©trica
            const angle = Math.PI / 6;
            const cosA = Math.cos(angle);
            const sinA = Math.sin(angle);
            
            // Pontos do cubo
            const points = [
                [-boxWidth/2, -boxHeight/2, -boxDepth/2], // 0: frente-esquerda-topo
                [boxWidth/2, -boxHeight/2, -boxDepth/2],  // 1: frente-direita-topo
                [boxWidth/2, boxHeight/2, -boxDepth/2],   // 2: frente-direita-base
                [-boxWidth/2, boxHeight/2, -boxDepth/2],  // 3: frente-esquerda-base
                [-boxWidth/2, -boxHeight/2, boxDepth/2],  // 4: tr√°s-esquerda-topo
                [boxWidth/2, -boxHeight/2, boxDepth/2],   // 5: tr√°s-direita-topo
                [boxWidth/2, boxHeight/2, boxDepth/2],    // 6: tr√°s-direita-base
                [-boxWidth/2, boxHeight/2, boxDepth/2]    // 7: tr√°s-esquerda-base
            ];
            
            // Fun√ß√£o para projetar ponto 3D para 2D
            function project(point) {
                const x = point[0] * cosA - point[2] * sinA;
                const y = point[1] - point[0] * sinA * 0.5 - point[2] * cosA * 0.5;
                return [x, y];
            }
            
            // Projetar pontos
            const projectedPoints = points.map(project);
            
            // Desenhar faces vis√≠veis do cubo
            ctx.lineWidth = 1;
            
            // Face superior
            ctx.beginPath();
            ctx.moveTo(projectedPoints[0][0], projectedPoints[0][1]);
            ctx.lineTo(projectedPoints[1][0], projectedPoints[1][1]);
            ctx.lineTo(projectedPoints[5][0], projectedPoints[5][1]);
            ctx.lineTo(projectedPoints[4][0], projectedPoints[4][1]);
            ctx.closePath();
            
            // Cor vari√°vel com base no passo do workflow
            let topColor;
            switch(workflowStep) {
                case 'model':
                    topColor = 'rgba(200, 200, 200, 0.8)';
                    break;
                case 'properties':
                    topColor = 'rgba(173, 216, 230, 0.8)';
                    break;
                case 'pressure':
                    topColor = 'rgba(255, 165, 0, 0.8)';
                    break;
                case 'safety':
                    topColor = 'rgba(144, 238, 144, 0.8)';
                    break;
                default:
                    topColor = 'rgba(200, 200, 200, 0.8)';
            }
            
            ctx.fillStyle = topColor;
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.stroke();
            
            // Face direita
            ctx.beginPath();
            ctx.moveTo(projectedPoints[1][0], projectedPoints[1][1]);
            ctx.lineTo(projectedPoints[2][0], projectedPoints[2][1]);
            ctx.lineTo(projectedPoints[6][0], projectedPoints[6][1]);
            ctx.lineTo(projectedPoints[5][0], projectedPoints[5][1]);
            ctx.closePath();
            
            ctx.fillStyle = 'rgba(180, 180, 180, 0.8)';
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.stroke();
            
            // Face frontal
            ctx.beginPath();
            ctx.moveTo(projectedPoints[0][0], projectedPoints[0][1]);
            ctx.lineTo(projectedPoints[1][0], projectedPoints[1][1]);
            ctx.lineTo(projectedPoints[2][0], projectedPoints[2][1]);
            ctx.lineTo(projectedPoints[3][0], projectedPoints[3][1]);
            ctx.closePath();
            
            ctx.fillStyle = 'rgba(160, 160, 160, 0.8)';
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.stroke();
            
            // Adicionar conte√∫do espec√≠fico com base no passo do workflow
            switch(workflowStep) {
                case 'model':
                    // Adicionar camadas simuladas ao modelo
                    for (let i = 1; i <= 5; i++) {
                        const y = projectedPoints[0][1] + (projectedPoints[3][1] - projectedPoints[0][1]) * i / 5;
                        
                        ctx.beginPath();
                        ctx.moveTo(projectedPoints[0][0], y);
                        ctx.lineTo(projectedPoints[1][0], y);
                        ctx.strokeStyle = '#777';
                        ctx.setLineDash([5, 5]);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                    
                    // Adicionar r√≥tulos para camadas
                    ctx.fillStyle = '#333';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText('Selo Superior', projectedPoints[0][0] - 10, projectedPoints[0][1] + 20);
                    ctx.fillText('Reservat√≥rio', projectedPoints[0][0] - 10, projectedPoints[0][1] + 70);
                    ctx.fillText('Selo Inferior', projectedPoints[0][0] - 10, projectedPoints[0][1] + 110);
                    break;
                    
                case 'properties':
                    // Adicionar pontos coloridos para propriedades
                    const gridSize = 5;
                    const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd'];
                    
                    for (let i = 0; i < gridSize; i++) {
                        for (let j = 0; j < gridSize; j++) {
                            const x = projectedPoints[0][0] + (projectedPoints[1][0] - projectedPoints[0][0]) * (i + 0.5) / gridSize;
                            const y = projectedPoints[0][1] + (projectedPoints[3][1] - projectedPoints[0][1]) * (j + 0.5) / gridSize;
                            
                            // Usar cores para representar diferentes propriedades
                            const colorIndex = Math.floor(Math.random() * colors.length);
                            
                            ctx.fillStyle = colors[colorIndex];
                            ctx.beginPath();
                            ctx.arc(x, y, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    
                    // Legenda
                    ctx.fillStyle = '#333';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText('Propriedades:', projectedPoints[2][0] + 10, projectedPoints[2][1] - 50);
                    
                    for (let i = 0; i < colors.length; i++) {
                        ctx.fillStyle = colors[i];
                        ctx.beginPath();
                        ctx.arc(projectedPoints[2][0] + 20, projectedPoints[2][1] - 40 + i * 15, 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#333';
                        ctx.textAlign = 'left';
                        const labels = ['M√≥dulo Young', 'Raz√£o Poisson', 'Coes√£o', '√Çngulo Atrito', 'Coef. Biot'];
                        ctx.fillText(labels[i], projectedPoints[2][0] + 30, projectedPoints[2][1] - 37 + i * 15);
                    }
                    break;
                    
                case 'pressure':
                    // Desenhar campo de press√£o com gradiente
                    const centerX = (projectedPoints[0][0] + projectedPoints[2][0]) / 2;
                    const centerY = (projectedPoints[0][1] + projectedPoints[2][1]) / 2;
                    const maxRadius = Math.min(
                        (projectedPoints[1][0] - projectedPoints[0][0]),
                        (projectedPoints[2][1] - projectedPoints[0][1])
                    ) * 0.8;
                    
                    // Gradiente radial
                    const gradient = ctx.createRadialGradient(
                        centerX, centerY, 0,
                        centerX, centerY, maxRadius
                    );
                    
                    gradient.addColorStop(0, 'rgba(255, 0, 0, 0.7)');
                    gradient.addColorStop(0.4, 'rgba(255, 165, 0, 0.5)');
                    gradient.addColorStop(0.7, 'rgba(255, 255, 0, 0.3)');
                    gradient.addColorStop(1, 'rgba(173, 216, 230, 0.1)');
                    
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, maxRadius, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Adicionar seta de po√ßo injetor
                    ctx.strokeStyle = '#1E88E5';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX, projectedPoints[0][1] - 20);
                    ctx.lineTo(centerX, centerY);
                    ctx.stroke();
                    
                    // C√≠rculo para injetor
                    ctx.fillStyle = '#1E88E5';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // R√≥tulo do po√ßo
                    ctx.fillStyle = '#1E88E5';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Injetor', centerX, projectedPoints[0][1] - 25);
                    break;
                    
                case 'safety':
                    // Desenhar mapa de SF na face superior
                    const gridSizeSF = 10;
                    
                    for (let i = 0; i < gridSizeSF; i++) {
                        for (let j = 0; j < gridSizeSF; j++) {
                            // Calcular coordenadas na face
                            const t1 = i / gridSizeSF;
                            const t2 = j / gridSizeSF;
                            
                            const x = projectedPoints[0][0] + t1 * (projectedPoints[1][0] - projectedPoints[0][0]) + 
                                    t2 * (projectedPoints[4][0] - projectedPoints[0][0]);
                            const y = projectedPoints[0][1] + t1 * (projectedPoints[1][1] - projectedPoints[0][1]) + 
                                    t2 * (projectedPoints[4][1] - projectedPoints[0][1]);
                            
                            // Calcular SF baseado na dist√¢ncia ao centro
                            const centerI = gridSizeSF / 2;
                            const centerJ = gridSizeSF / 2;
                            
                            const dist = Math.sqrt(Math.pow(i - centerI, 2) + Math.pow(j - centerJ, 2));
                            const maxDist = Math.sqrt(Math.pow(gridSizeSF, 2));
                            
                            // SF diminui pr√≥ximo ao centro
                            const sf = 0.8 + 1.2 * (dist / (maxDist/2));
                            
                            let color;
                            if (sf < 1.0) {
                                color = '#ef4444'; // Vermelho
                            } else if (sf < 1.2) {
                                color = '#f59e0b'; // Amarelo
                            } else {
                                color = '#10b981'; // Verde
                            }
                            
                            ctx.fillStyle = color;
                            ctx.beginPath();
                            ctx.arc(x, y, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    
                    // Legenda
                    ctx.fillStyle = '#333';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText('Fator de Seguran√ßa:', projectedPoints[2][0] + 10, projectedPoints[2][1] - 40);
                    
                    const sfColors = ['#ef4444', '#f59e0b', '#10b981'];
                    const sfLabels = ['SF < 1.0 (Falha)', '1.0 ‚â§ SF < 1.2 (Aten√ß√£o)', 'SF ‚â• 1.2 (Seguro)'];
                    
                    for (let i = 0; i < sfColors.length; i++) {
                        ctx.fillStyle = sfColors[i];
                        ctx.beginPath();
                        ctx.arc(projectedPoints[2][0] + 20, projectedPoints[2][1] - 30 + i * 15, 4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#333';
                        ctx.textAlign = 'left';
                        ctx.fillText(sfLabels[i], projectedPoints[2][0] + 30, projectedPoints[2][1] - 27 + i * 15);
                    }
                    break;
            }
            
            ctx.restore();
            
            // Adicionar comandos Petrel na parte inferior
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            
            let commandText;
            switch(workflowStep) {
                case 'model':
                    commandText = 'Process > Geomechanics > Import Model...';
                    break;
                case 'properties':
                    commandText = 'Process > Geomechanics > Mechanical Properties...';
                    break;
                case 'pressure':
                    commandText = 'Process > Geomechanics > Import Results > Pressure...';
                    break;
                case 'safety':
                    commandText = 'Process > Geomechanics > Calculate Safety Factors...';
                    break;
                default:
                    commandText = 'Process > Geomechanics...';
            }
            
            ctx.fillStyle = '#555';
            ctx.fillRect(0, height - 25, width, 25);
            
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'left';
            ctx.fillText(commandText, 10, height - 8);
        }
        
        // Fun√ß√£o para atualizar par√¢metros globais
        function updateGlobalParameters() {
            // Obter valores dos controles
            const depth = parseInt(document.getElementById('global-depth-slider').value);
            document.getElementById('global-depth-value').textContent = depth + ' m';
            
            const tectonicRegime = document.getElementById('global-tectonic-regime').value;
            
            const injectionPercent = parseInt(document.getElementById('global-injection-slider').value);
            document.getElementById('global-injection-value').textContent = injectionPercent + '%';
            
            const usePoroelastic = document.getElementById('global-poroelastic-toggle').checked;
            
            // Atualizar outros controles com base nos par√¢metros globais
            // (Implementa√ß√£o simplificada - em um caso real, ter√≠amos mais conex√µes)
            
            // Atualizar todos os gr√°ficos
            drawAllPlots();
        }
        
        // Fun√ß√£o para resetar par√¢metros
        function resetParameters() {
            // Resetar valores dos controles para padr√µes
            document.getElementById('global-depth-slider').value = 2000;
            document.getElementById('global-depth-value').textContent = '2000 m';
            
            document.getElementById('global-tectonic-regime').value = 'normal';
            
            document.getElementById('global-injection-slider').value = 50;
            document.getElementById('global-injection-value').textContent = '50%';
            
            document.getElementById('global-poroelastic-toggle').checked = true;
            
            // Resetar controles individuais
            document.getElementById('density-slider').value = 2500;
            document.getElementById('pp-gradient-slider').value = 10;
            document.getElementById('biot-slider').value = 0.8;
            document.getElementById('poisson-slider').value = 0.25;
            document.getElementById('deltap-slider').value = 10;
            document.getElementById('shmin-gradient-slider').value = 16;
            document.getElementById('injection-rate-slider').value = 50;
            document.getElementById('poroelastic-toggle').checked = true;
            document.getElementById('cohesion-slider').value = 5;
            document.getElementById('friction-angle-slider').value = 30;
            document.getElementById('stress-ratio-slider').value = 2;
            document.getElementById('sigma1-slider').value = 40;
            document.getElementById('sigma3-slider').value = 20;
            document.getElementById('pp-slider').value = 10;
            document.getElementById('mohr-cohesion-slider').value = 5;
            document.getElementById('mohr-friction-slider').value = 30;
            document.getElementById('mohr-poroelastic-toggle').checked = true;
            
            // Atualizar valores de texto
            document.getElementById('density-value').textContent = '2500 kg/m¬≥';
            document.getElementById('pp-gradient-value').textContent = '10.0 kPa/m';
            document.getElementById('biot-value').textContent = '0.80';
            document.getElementById('poisson-value').textContent = '0.25';
            document.getElementById('deltap-value').textContent = '10 MPa';
            document.getElementById('shmin-gradient-value').textContent = '16.0 kPa/m';
            document.getElementById('injection-rate-value').textContent = '50 m¬≥/dia';
            document.getElementById('cohesion-value').textContent = '5 MPa';
            document.getElementById('friction-angle-value').textContent = '30¬∞';
            document.getElementById('stress-ratio-value').textContent = '2.0';
            document.getElementById('sigma1-value').textContent = '40 MPa';
            document.getElementById('sigma3-value').textContent = '20 MPa';
            document.getElementById('pp-value').textContent = '10 MPa';
            document.getElementById('mohr-cohesion-value').textContent = '5 MPa';
            document.getElementById('mohr-friction-value').textContent = '30¬∞';
            
            // Atualizar seletores para valores padr√£o
            document.getElementById('tectonic-regime').value = 'normal';
            document.getElementById('stress-view-type').value = 'sv';
            document.getElementById('pressure-time').value = 'initial';
            document.getElementById('poroelastic-component').value = 'dshmin';
            document.getElementById('tensile-map-type').value = 'pressure';
            document.getElementById('shear-map-type').value = 'differential';
            document.getElementById('view-plane').value = 'horizontal';
            document.getElementById('safety-view-mode').value = 'hydraulic';
            document.getElementById('petrel-workflow-step').value = 'model';
            
            // Atualizar todos os gr√°ficos
            drawAllPlots();
        }
        
        // Fun√ß√£o para mostrar/esconder painel de controle flutuante
        function toggleControlPanel() {
            const panel = document.querySelector('.floating-controls');
            panel.classList.toggle('visible');
        }
        
        // Inicializa√ß√£o ap√≥s carregamento da p√°gina
        window.onload = function() {
            // Inicializar canvases
            initCanvases();
            
            // Configurar toggle para painel de controle
            document.querySelector('.toggle-controls').addEventListener('click', toggleControlPanel);
            
            // Mostrar painel de controle no in√≠cio
            document.querySelector('.floating-controls').classList.add('visible');
        };
    </script>
</body>
</html>